"use strict";(()=>{var h=class a{constructor(e){this.resolver=e}static forUrl(e){return a.forResolver(async({start:t,end:r})=>{let n=await fetch(e,{headers:{Range:`bytes=${t}-${r}`}}),o=Number(n.headers.get("Content-Range").split("/")[1]);return{data:await n.arrayBuffer(),totalLength:o}})}static forResolver(e){let t=new a(async(r,n,o)=>(await e({start:r,end:n,expectedLength:o})).data);return t.originalResolver=e,t}getResolver(){return this.originalResolver}async get(e,t){let r=await this.resolver(e,t);return new TextDecoder().decode(r)}};var m=(t=>(t[t.JSONL=0]="JSONL",t[t.CSV=1]="CSV",t))(m||{});async function g(a){if(a.byteLength<4)throw new Error(`invalid metadata size ${a.byteLength}`);let e=new DataView(a),t=e.getUint16(0),r=e.getUint16(2);if(a.byteLength<4+r)throw new Error(`invalid metadata size ${a.byteLength}`);let n=a.slice(4,4+r);return{fieldName:new TextDecoder("utf-8").decode(n),fieldType:t}}function N(a){let e=new Map;for(let r of a)if(!e.has(r.fieldName))e.set(r.fieldName,[r.fieldType]);else{let n=e.get(r.fieldName);n?.push(r.fieldType),e.set(r.fieldName,n)}let t=[];return e.forEach((r,n)=>{t.push({fieldName:n,fieldTypes:r})}),t}var v=class a{constructor(e,t,r,n,o,i){this.keys=e,this.leafPointers=t,this.internalPointers=r,this.dataFileResolver=n,this.fileFormat=o,this.pageFieldType=i}leaf(){return this.leafPointers.length>0}pointer(e){return this.leaf()?this.leafPointers[e]:{offset:this.internalPointers[e],length:0}}numPointers(){return this.internalPointers.length+this.leafPointers.length}size(){let e=4;for(let t=0;t<=this.keys.length-1;t++){let r=this.keys[t];r.dataPointer.length>0?e+=16:e+=4*r.value.byteLength}for(let t=0;t<=this.leafPointers.length-1;t++)e+=12;for(let t=0;t<=this.internalPointers.length-1;t++)e+=8;return BigInt(e)}async unmarshalBinary(e){let t=new DataView(e),r=t.getUint32(0);if(r>2147483647&&(r=r-4294967296),r<0?(this.leafPointers=new Array(-r).fill({offset:0n,length:0}).map(()=>({offset:0n,length:0})),this.keys=new Array(-r).fill(null).map(()=>new f({offset:0n,length:0},new ArrayBuffer(0)))):(this.internalPointers=Array(r+1).fill(0n).map(()=>0n),this.keys=new Array(r).fill(null).map(()=>new f({offset:0n,length:0},new ArrayBuffer(0)))),r===0)throw new Error("empty node");let o=4;for(let i=0;i<=this.keys.length-1;i++){t=new DataView(e,o,4);let l=t.getUint32(0);if(l===-1>>>0){t=new DataView(e,o+4);let s=t.getBigUint64(0),c=t.getUint32(8);this.keys[i].setDataPointer({offset:s,length:c});let d=this.keys[i].dataPointer,{data:u}=await this.dataFileResolver({start:Number(d.offset),end:Number(d.offset)+d.length-1}),w=await this.parseValue(u);this.keys[i].setValue(w),o+=16}else{let s=e.slice(o+4,o+4+l);this.keys[i].setValue(s),o+=4+l}}for(let i=0;i<=this.leafPointers.length-1;i++)t=new DataView(e,o),this.leafPointers[i].offset=t.getBigUint64(0),this.leafPointers[i].length=t.getUint32(8),o+=12;for(let i=0;i<=this.internalPointers.length-1;i++)t=new DataView(e,o),this.internalPointers[i]=t.getBigUint64(0),o+=8}async parseValue(e){let t=new TextDecoder().decode(e);switch(this.fileFormat){case 0:let r=JSON.parse(t);switch(this.pageFieldType){case 7:if(r!==null)throw new Error(`unrecognized value for null type: ${r}`);return new ArrayBuffer(0);case 6:let n=new ArrayBuffer(1);return new DataView(n).setUint8(0,r?1:0),n;case 3:case 1:case 2:let i=new ArrayBuffer(8);return new DataView(i).setFloat64(0,r,!0),i;case 0:return new TextEncoder().encode(r).buffer;default:throw new Error(`Unexpected Field Type. Got: ${this.pageFieldType}`)}case 1:}throw new Error("unexpected parsing error occured")}static async fromMemoryPointer(e,t,r,n,o){let{data:i}=await t({start:Number(e.offset),end:Number(e.offset)+4096-1}),l=new a([],[],[],r,n,o);try{await l.unmarshalBinary(i)}catch{console.log("an error while unmarshaling occured")}return{node:l,bytesRead:4096}}};var R=class{constructor(e,t){this.tree=e,this.key=t,this.records=[]}async init(){let e=await this.tree.root();if(e.rootNode===null)return!1;let t=e.rootNode,r=e.pointer,n=await this.tree.traverse(this.key,t,r);return this.records=n,!0}getKey(){return this.records[0].node.keys[this.records[0].index]}getPointer(){return this.records[0].node.pointer(this.records[0].index)}async increment(e,t){if(e===this.records.length)return!1;this.records[e].index+=t;let r=this.records[e].index<0,n=this.records[e].index>=this.records[e].node.numPointers();if(r||n){if(!this.increment(e+1,t)||!this.records[e+1])return!1;try{let o=await this.tree.readNode(this.records[e+1].node.pointer(this.records[e+1].index));this.records[e].node=o,r?this.records[e].index=this.records[e].node.numPointers()-1:this.records[e].index=0}catch{return!1}}return!0}async next(){return this.records.length===0?await this.init():this.increment(0,1)}async prev(){return this.records.length===0&&!await this.init()?!1:this.increment(0,-1)}};var x=class{constructor(e,t,r,n,o){this.tree=e,this.meta=t,this.dataFileResolver=r,this.fileFormat=n,this.pageFieldType=o}async root(){let e=await this.meta.root();if(!e||e.length===0)return{rootNode:null,pointer:e};let t=await this.readNode(e);return t?{rootNode:t,pointer:e}:{rootNode:null,pointer:e}}async readNode(e){try{let{node:t,bytesRead:r}=await v.fromMemoryPointer(e,this.tree,this.dataFileResolver,this.fileFormat,this.pageFieldType);if(!r)throw new Error("bytes read do not line up");return t}catch(t){throw new Error(`${t}`)}}iter(e){return new R(this,e)}async traverse(e,t,r){let[n,o]=q(t.keys,e);if(t.leaf())return[{node:t,index:n,pointer:r}];o&&(n+=1);let i=t.pointer(n),l=await this.readNode(i);return[...await this.traverse(e,l,i),{node:t,index:n,pointer:r}]}async find(e){let t=this.iter(e);return await t.next()?[t.getKey(),t.getPointer()]:[new f({offset:0n,length:0},new Uint8Array(0).buffer),{offset:0n,length:0}]}},f=class{constructor(e,t){this.dataPointer=e,this.value=t}setDataPointer(e){this.dataPointer=e}setValue(e){this.value=e}static compareBytes(e,t){let r=new Uint8Array(e),n=new Uint8Array(t),o=Math.min(r.length,n.length);for(let i=0;i<o;i++)if(r[i]!==n[i])return r[i]<n[i]?-1:1;return r.length<n.length?-1:r.length>n.length?1:0}};function S(a,e){let t=f.compareBytes(a.value,e.value);return t!==0?t:a.dataPointer.offset>e.dataPointer.offset?1:a.dataPointer.offset<e.dataPointer.offset?-1:a.dataPointer.length>e.dataPointer.length?1:a.dataPointer.length<e.dataPointer.length?-1:0}function q(a,e){let t=a.length,r=0,n=t;for(;r<n;){let o=Math.floor((r+n)/2);S(a[o],e)<0?r=o+1:n=o}return[r,r<t&&S(a[r],e)===0]}var T=class a{constructor(e){this.database=e;this.queryObject={where:[],orderBy:void 0,select:void 0,limit:void 0}}toQuery(){return{where:this.queryObject.where?[...this.queryObject.where]:[],orderBy:this.queryObject.orderBy?[...this.queryObject.orderBy]:void 0,select:this.queryObject.select?[...this.queryObject.select]:void 0,limit:this.queryObject.limit}}get(){}where(e,t,r){let n=new a(this.database);return n.queryObject={...this.queryObject,where:[...this.queryObject.where||[],{key:e,operation:t,value:r}]},n}orderBy(e,t){let r=new a(this.database);return r.queryObject={...this.queryObject,orderBy:[...this.queryObject.orderBy||[],{key:e,direction:t}]},r}select(e){let t=new a(this.database);return t.queryObject={...this.queryObject,select:e},t}limit(e){let t=new a(this.database);return t.queryObject={...this.queryObject,limit:e},t}};var y=(s=>(s[s.String=0]="String",s[s.Int64=1]="Int64",s[s.Uint64=2]="Uint64",s[s.Float64=3]="Float64",s[s.Object=4]="Object",s[s.Array=5]="Array",s[s.Boolean=6]="Boolean",s[s.Null=7]="Null",s))(y||{});var B=class a{constructor(e,t){this.dataFile=e;this.indexFile=t}static forDataFileAndIndexFile(e,t){return new a(e,t)}async fields(){return await this.indexFile.indexHeaders()}async*query(e){if(new Set((e.where??[]).map(n=>n.key)).size>1)throw new Error("composite indexes not supported... yet");let t=await this.indexFile.indexHeaders(),r=await Promise.all((e.where??[]).map(async({key:n,value:o,operation:i})=>{if(!t.find(P=>P.fieldName===n))throw new Error("field not found");let s,c;if(n===null)c=7,s=new ArrayBuffer(0);else switch(typeof o){case"bigint":case"number":c=3,s=new ArrayBuffer(8),new DataView(s).setFloat64(0,Number(o),!0);break;case"boolean":c=6,s=new ArrayBuffer(1),new DataView(s).setUint8(0,o?1:0);break;case"string":c=0,s=new TextEncoder().encode(o).buffer;break;default:throw new Error("unmatched key type")}let d=await this.indexFile.seek(n,c),u=[],w=d[0],k=this.dataFile.getResolver();if(k===void 0)throw new Error("data file is undefined");let L=new f({offset:0n,length:0},s),{format:U}=await this.indexFile.metadata(),{fieldType:E}=await g(await w.metadata()),j=new x(this.indexFile.getResolver(),w,k,U,E),A=[],D=new Set;if(i===">"||i===">="||i==="=="){let P=j.iter(L);for(;await P.next();){let b=P.getKey();f.compareBytes(s,b.value)===0&&(D.has(b.dataPointer.offset)&&console.log("not unique"),D.add(b.dataPointer.offset),console.log("equal"),A.push(b.dataPointer))}}return u.push(...A),console.log(u),[n,u]}));console.log("field ranges");for(let[n,o]of r)for(let{offset:i,length:l}of o){let s=await this.dataFile.get(Number(i),Number(i)+l-1);console.log(s),yield s}}where(e,t,r){return new T(this).where(e,t,r)}};var Q=4096,$=2n**64n-1n,V=class a{constructor(e,t){this.metaPagePromise=null;this.resolver=e,this.offset=t,this.metaPageData=null}async root(){let t=(await this.getMetaPage()).slice(0,12),r=new DataView(t),n=r.getBigUint64(0),o=r.getUint32(8);return{offset:n,length:o}}async metadata(){let e=await this.getMetaPage(),r=new DataView(e,24).getUint32(0);return e.slice(28,28+r)}async getMetaPage(){return this.metaPageData?this.metaPageData:(this.metaPagePromise||(this.metaPagePromise=this.resolver({start:Number(this.offset),end:Number(this.offset)+Q-1}).then(({data:e})=>(this.metaPageData=e,this.metaPagePromise=null,e)).catch(e=>{throw this.metaPagePromise=null,e})),this.metaPagePromise)}async next(){let e=await this.getMetaPage(),r=new DataView(e,12,8).getBigUint64(0);return r===$?null:new a(this.resolver,r)}getOffset(){return this.offset}};function I(a,e){let t=e.page(0);return new V(a,t)}var F=class extends Error{constructor(){super("length integrity error")}};var z=4096,M=class{constructor(e){this.pageSize=z;this.resolver=e}async readPage(e){if(e<0)throw new Error("page cannot be indexed");let t=(e+1)*this.pageSize,r=t+this.pageSize-1,{data:n}=await this.resolver({start:t,end:r-1});return n}page(e){return e<0?BigInt(0):BigInt(e+1)*BigInt(this.pageSize)}};var p=class a{static async forUrl(e){return await a.forResolver(async({start:t,end:r,expectedLength:n})=>{let o=await fetch(e,{headers:{Range:`bytes=${t}-${r}`}}),i=Number(o.headers.get("Content-Range").split("/")[1]);if(n&&i!==n)throw new F;return{data:await o.arrayBuffer(),totalLength:i}})}static async forResolver(e){return new O(e)}};var O=class{constructor(e){this.resolver=e}getResolver(){return this.resolver}async tree(){if(this._tree)return this._tree;let e=new M(this.resolver),t=I(this.resolver,e);return this._tree=t,t}async metadata(){let t=await(await this.tree()).metadata();if(t.byteLength<10)throw new Error(`incorrect byte length! Want: 10, got ${t.byteLength}`);let r=new DataView(t),n=r.getUint8(0),o=r.getUint8(1);if(Object.values(m).indexOf(o)===-1)throw new Error(`unexpected file format. Got: ${o}`);let i=r.getBigUint64(2);return{version:n,format:o,readOffset:i}}async seek(e,t){let r=await this.tree(),n=[];for(;r;){let o=await r.next();if(o===null)return n;let i=await g(await o.metadata());i.fieldName===e&&(t===3?(i.fieldType===3||i.fieldType===1||i.fieldType===2)&&n.push(o):i.fieldType===t&&n.push(o)),r=o}return console.log(n),n}async indexHeaders(){let e=[],t=await this.tree();for(;t;){let r=await t.next();if(r===null)return N(e);let n=await r.metadata(),o=await g(n);e.push(o),t=r}return N(e)}};async function H(a,e){return B.forDataFileAndIndexFile(typeof a=="string"?h.forUrl(a):h.forResolver(a),typeof e=="string"?await p.forUrl(e):await p.forResolver(e))}globalThis.Appendable={init:H,FieldType:y};})();
//# sourceMappingURL=appendable.min.js.map
