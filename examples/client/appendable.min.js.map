{
  "version": 3,
  "sources": ["../src/data-file.ts", "../src/index-file/meta.ts", "../src/btree/node.ts", "../src/btree/traversal.ts", "../src/btree/bptree.ts", "../src/db/query-builder.ts", "../src/db/database.ts", "../src/btree/multi.ts", "../src/resolver.ts", "../src/btree/pagefile.ts", "../src/index-file/index-file.ts", "../src/index.ts"],
  "sourcesContent": ["import { RangeResolver } from \"./resolver\";\n\nexport class DataFile {\n\tprivate originalResolver?: RangeResolver;\n\n\tprivate constructor(\n\t\tprivate resolver: (\n\t\t\tstart: number,\n\t\t\tend: number,\n\t\t\texpectedLength?: number\n\t\t) => Promise<ArrayBuffer>\n\t) {}\n\n\tstatic forUrl(url: string) {\n\t\treturn DataFile.forResolver(async ({ start, end }) => {\n\t\t\tconst response = await fetch(url, {\n\t\t\t\theaders: { Range: `bytes=${start}-${end}` },\n\t\t\t});\n\t\t\tconst totalLength = Number(\n\t\t\t\tresponse.headers.get(\"Content-Range\")!.split(\"/\")[1]\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tdata: await response.arrayBuffer(),\n\t\t\t\ttotalLength: totalLength,\n\t\t\t};\n\t\t});\n\t}\n\n\tstatic forResolver(resolver: RangeResolver) {\n\t\tconst instance = new DataFile(async (start, end, expectedLength?) => {\n\t\t\tconst result = await resolver({ start, end, expectedLength });\n\t\t\treturn result.data;\n\t\t});\n\t\tinstance.originalResolver = resolver; \n\t\treturn instance;\n  }\n  \n  getResolver(): RangeResolver | undefined {\n    return this.originalResolver;\n}\n\n\tasync get(startByteOffset: number, endByteOffset: number) {\n\t\tconst data = await this.resolver(startByteOffset, endByteOffset);\n\t\treturn new TextDecoder().decode(data);\n\t}\n}\n", "\nexport enum FileFormat {\n\tJSONL = 0,\n\tCSV = 1,\n}\n\nexport type FileMeta = {\n\tversion: number;\n\tformat: FileFormat;\n\treadOffset: bigint;\n};\n\nexport async function readFileMeta(buffer: ArrayBuffer): Promise<FileMeta> {\n\tif (buffer.byteLength !== 10) {\n\t\tthrow new Error(\n\t\t\t`incorrect byte length! Want: 10, got ${buffer.byteLength}`\n\t\t);\n\t}\n\n\tconst dataView = new DataView(buffer);\n\n\tconst version = dataView.getUint8(0);\n\tconst formatByte = dataView.getUint8(1);\n\n\tif (Object.values(FileFormat).indexOf(formatByte) === -1) {\n\t\tthrow new Error(`unexpected file format. Got: ${formatByte}`);\n\t}\n\n\n\tconst readOffset = dataView.getBigUint64(2);\n\n\treturn {\n\t\tversion,\n\t\tformat: formatByte,\n\t\treadOffset,\n\t};\n}\n\nexport type IndexMeta = {\n\tfieldName: string;\n\tfieldType: number;\n};\n\nexport type IndexHeader = {\n\tfieldName: string;\n\tfieldTypes: number[];\n}\n\nexport async function readIndexMeta(\n\tbuffer: ArrayBuffer,\n): Promise<IndexMeta> {\n\tif (buffer.byteLength < 4) {\n\t\tthrow new Error(`invalid metadata size ${buffer.byteLength}`);\n\t}\n\n\tconst dataView = new DataView(buffer);\n\tconst fieldType = dataView.getUint16(0);\n\tconst nameLength = dataView.getUint16(2);\n\n\tif (buffer.byteLength < 4 + nameLength) {\n\t\tthrow new Error(`invalid metadata size ${buffer.byteLength}`);\n\t}\n\n\tconst fieldNameBuffer = buffer.slice(4, 4+ nameLength);\n    const fieldName = new TextDecoder(\"utf-8\").decode(fieldNameBuffer);\n\n\treturn {\n\t\tfieldName,\n\t\tfieldType,\n\t};\n}\n\nexport function collectIndexMetas(indexMetas: IndexMeta[]): IndexHeader[] {\n    const headersMap: Map<string, number[]> = new Map();\n\n    for (const meta of indexMetas) {\n        if (!headersMap.has(meta.fieldName)) {\n            headersMap.set(meta.fieldName, [meta.fieldType]);\n        } else {\n            const updatedTypes = headersMap.get(meta.fieldName);\n            updatedTypes?.push(meta.fieldType);\n            headersMap.set(meta.fieldName, updatedTypes!!);\n        }\n    }\n\n    const indexHeaders: IndexHeader[] = [];\n    headersMap.forEach((fieldTypes, fieldName) => {\n        indexHeaders.push({ fieldName, fieldTypes });\n    });\n\n    return indexHeaders;\n}", "import { FieldType } from \"../db/database\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { RangeResolver } from \"../resolver\";\nimport { BPTree, ReferencedValue } from \"./bptree\";\n\nexport type MemoryPointer = { offset: bigint; length: number };\nexport class BPTreeNode {\n\tpublic keys: ReferencedValue[];\n\tpublic leafPointers: MemoryPointer[];\n\tpublic internalPointers: bigint[];\n\tprivate readonly dataFileResolver: RangeResolver;\n\tprivate fileFormat: FileFormat;\n\tprivate pageFieldType: FieldType;\n\n\tconstructor(\n\t\tkeys: ReferencedValue[],\n\t\tleafPointers: MemoryPointer[],\n\t\tinternalPointers: bigint[],\n\t\tdataFileResolver: RangeResolver,\n\t\tfileFormat: FileFormat,\n\t\tpageFieldType: FieldType\n\t) {\n\t\tthis.keys = keys;\n\t\tthis.leafPointers = leafPointers;\n\t\tthis.internalPointers = internalPointers;\n\t\tthis.dataFileResolver = dataFileResolver;\n\t\tthis.fileFormat = fileFormat;\n\t\tthis.pageFieldType = pageFieldType;\n\t}\n\n\tleaf(): boolean {\n\t\treturn this.leafPointers.length > 0;\n\t}\n\n\tpointer(i: number): MemoryPointer {\n\t\tif (this.leaf()) {\n\t\t\treturn this.leafPointers[i];\n\t\t}\n\n\t\treturn {\n\t\t\toffset: this.internalPointers[i],\n\t\t\tlength: 0, // disregard since this is a free value in golang version\n\t\t};\n\t}\n\n\tnumPointers(): number {\n\t\treturn this.internalPointers.length + this.leafPointers.length;\n\t}\n\n\tsize(): bigint {\n\t\tlet size = 4;\n\n\t\tfor (let idx = 0; idx <= this.keys.length - 1; idx++) {\n\t\t\tconst k = this.keys[idx];\n\t\t\tif (k.dataPointer.length > 0) {\n\t\t\t\tsize += 4 + 12;\n\t\t\t} else {\n\t\t\t\tsize += 4 * k.value.byteLength;\n\t\t\t}\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n\t\t\tsize += 12;\n\t\t}\n\t\tfor (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n\t\t\tsize += 8;\n\t\t}\n\n\t\treturn BigInt(size);\n\t}\n\n\tasync unmarshalBinary(buffer: ArrayBuffer) {\n\t\tlet dataView = new DataView(buffer);\n\t\tlet size = dataView.getUint32(0);\n\n\t\tif (size > 2147483647) {\n\t\t\tsize = size - 4294967296;\n\t\t}\n\n\t\tconst leaf = size < 0;\n\n\t\tif (leaf) {\n\t\t\tthis.leafPointers = new Array<MemoryPointer>(-size)\n\t\t\t\t.fill({ offset: 0n, length: 0 })\n\t\t\t\t.map(() => ({\n\t\t\t\t\toffset: 0n,\n\t\t\t\t\tlength: 0,\n\t\t\t\t}));\n\t\t\tthis.keys = new Array(-size)\n\t\t\t\t.fill(null)\n\t\t\t\t.map(\n\t\t\t\t\t() =>\n\t\t\t\t\t\tnew ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0))\n\t\t\t\t);\n\t\t} else {\n\t\t\tthis.internalPointers = Array<bigint>(size + 1)\n\t\t\t\t.fill(0n)\n\t\t\t\t.map(() => 0n);\n\t\t\tthis.keys = new Array(size)\n\t\t\t\t.fill(null)\n\t\t\t\t.map(\n\t\t\t\t\t() =>\n\t\t\t\t\t\tnew ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0))\n\t\t\t\t);\n\t\t}\n\n\t\tif (size === 0) {\n\t\t\tthrow new Error(\"empty node\");\n\t\t}\n\n\t\tlet m = 4;\n\t\tfor (let idx = 0; idx <= this.keys.length - 1; idx++) {\n\t\t\t// this is the case when we store the pointer to the datafile\n\t\t\tdataView = new DataView(buffer, m, 4);\n\t\t\tconst l = dataView.getUint32(0);\n\t\t\tif (l === ~0 >>> 0) {\n\t\t\t\tdataView = new DataView(buffer, m + 4);\n\t\t\t\tconst dpOffset = dataView.getBigUint64(0);\n\t\t\t\tconst dpLength = dataView.getUint32(8);\n\t\t\t\tthis.keys[idx].setDataPointer({ offset: dpOffset, length: dpLength });\n\n\t\t\t\tconst dp = this.keys[idx].dataPointer;\n\n\t\t\t\tconst { data } = await this.dataFileResolver({\n\t\t\t\t\tstart: Number(dp.offset),\n\t\t\t\t\tend: Number(dp.offset) + dp.length - 1,\n\t\t\t\t});\n\n\t\t\t\tconst parsedData = await this.parseValue(data);\n\n\t\t\t\tthis.keys[idx].setValue(parsedData);\n\t\t\t\tm += 4 + 12;\n\t\t\t} else {\n\t\t\t\t// we are storing the values directly in the referenced value\n\t\t\t\tconst value = buffer.slice(m + 4, m + 4 + l);\n\t\t\t\tthis.keys[idx].setValue(value);\n\t\t\t\tm += 4 + l;\n\t\t\t}\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n\t\t\tdataView = new DataView(buffer, m);\n\t\t\tthis.leafPointers[idx].offset = dataView.getBigUint64(0);\n\t\t\tthis.leafPointers[idx].length = dataView.getUint32(8);\n\n\t\t\tm += 12;\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n\t\t\tdataView = new DataView(buffer, m);\n\t\t\tthis.internalPointers[idx] = dataView.getBigUint64(0);\n\n\t\t\tm += 8;\n\t\t}\n\n\t}\n\n\tasync parseValue(incomingData: ArrayBuffer): Promise<ArrayBuffer> {\n\t\tconst stringData = new TextDecoder().decode(incomingData);\n\n\t\tswitch (this.fileFormat) {\n\t\t\tcase FileFormat.JSONL:\n\t\t\t\tconst jValue = JSON.parse(stringData);\n\n\t\t\t\tswitch (this.pageFieldType) {\n\t\t\t\t\tcase FieldType.Null:\n\t\t\t\t\t\tif (jValue !== null) {\n\t\t\t\t\t\t\tthrow new Error(`unrecognized value for null type: ${jValue}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new ArrayBuffer(0);\n\n\t\t\t\t\tcase FieldType.Boolean:\n\t\t\t\t\t\tconst boolBuf = new ArrayBuffer(1);\n\t\t\t\t\t\tlet boolBufView = new DataView(boolBuf);\n\t\t\t\t\t\tboolBufView.setUint8(0, jValue ? 1 : 0); // we can do extra validation here\n\t\t\t\t\t\treturn boolBuf;\n\n\t\t\t\t\tcase FieldType.Float64:\n\t\t\t\t\tcase FieldType.Int64:\n\t\t\t\t\tcase FieldType.Uint64:\n\t\t\t\t\t\tconst floatBuf = new ArrayBuffer(8);\n\t\t\t\t\t\tlet floatBufView = new DataView(floatBuf);\n\t\t\t\t\t\tfloatBufView.setFloat64(0, jValue, true);\n\n\t\t\t\t\t\treturn floatBuf;\n\n\t\t\t\t\tcase FieldType.String:\n\t\t\t\t\t\tconst e = new TextEncoder().encode(jValue);\n\t\t\t\t\t\treturn e.buffer;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unexpected Field Type. Got: ${this.pageFieldType}`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tcase FileFormat.CSV:\n\t\t}\n\n\t\tthrow new Error(\"unexpected parsing error occured\");\n\t}\n\n\tstatic async fromMemoryPointer(\n\t\tmp: MemoryPointer,\n\t\tresolver: RangeResolver,\n\t\tdataFilePointer: RangeResolver,\n\t\tfileFormat: FileFormat,\n\t\tpageFieldType: FieldType\n\t): Promise<{ node: BPTreeNode; bytesRead: number }> {\n\t\tconst { data: bufferData } = await resolver({\n\t\t\tstart: Number(mp.offset),\n\t\t\tend: Number(mp.offset) + 4096 - 1,\n\t\t});\n\t\tconst node = new BPTreeNode(\n\t\t\t[],\n\t\t\t[],\n\t\t\t[],\n\t\t\tdataFilePointer,\n\t\t\tfileFormat,\n\t\t\tpageFieldType\n\t\t);\n\n\t\ttry {\n\t\t\tawait node.unmarshalBinary(bufferData);\n\t\t} catch {\n\t\t\tconsole.log(\"an error while unmarshaling occured\")\n\t\t}\n\t\treturn { node, bytesRead: 4096 };\n\t}\n}\n", "import { BPTree, ReferencedValue } from \"./bptree\";\nimport { BPTreeNode, MemoryPointer } from \"./node\";\n\nexport type TraversalRecord = {\n\tnode: BPTreeNode;\n\tindex: number;\n\tpointer: MemoryPointer;\n};\n\nexport class TraversalIterator {\n\tprivate tree: BPTree;\n\tprivate key: ReferencedValue;\n\tprivate records: TraversalRecord[];\n\n\tconstructor(tree: BPTree, key: ReferencedValue) {\n\t\tthis.tree = tree;\n\t\tthis.key = key;\n\t\tthis.records = []; // note this works iff all records are non-empty\n\t}\n\n\tasync init(): Promise<boolean> {\n\t\tconst rootResponse = await this.tree.root();\n\n\t\tif (rootResponse.rootNode === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst root = rootResponse.rootNode;\n\t\tconst offset = rootResponse.pointer;\n\t\tconst path = await this.tree.traverse(this.key, root, offset);\n\t\tthis.records = path;\n\t\treturn true;\n\t}\n\n\tgetKey(): ReferencedValue {\n\t\treturn this.records[0].node.keys[this.records[0].index];\n\t}\n\n\tgetPointer(): MemoryPointer {\n\t\treturn this.records[0].node.pointer(this.records[0].index);\n\t}\n\n\tasync increment(i: number, delta: number): Promise<boolean> {\n\t\tif (i === this.records.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.records[i].index += delta;\n\t\tconst rolloverLeft = this.records[i].index < 0;\n\t\tconst rolloverRight =\n\t\t\tthis.records[i].index >= this.records[i].node.numPointers();\n\n\t\tif (rolloverLeft || rolloverRight) {\n\t\t\tif (!this.increment(i + 1, delta)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.records[i + 1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst node = await this.tree.readNode(\n\t\t\t\t\tthis.records[i + 1].node.pointer(this.records[i + 1].index)\n\t\t\t\t);\n\n\t\t\t\t// propagate the rollover\n\t\t\t\tthis.records[i].node = node;\n\n\t\t\t\tif (rolloverLeft) {\n\t\t\t\t\tthis.records[i].index = this.records[i].node.numPointers() - 1;\n\t\t\t\t} else {\n\t\t\t\t\tthis.records[i].index = 0;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync next(): Promise<boolean> {\n\t\tif (this.records.length === 0) {\n\t\t\treturn await this.init();\n\t\t}\n\n\t\treturn this.increment(0, 1);\n\t}\n\n\tasync prev(): Promise<boolean> {\n\t\tif (this.records.length === 0) {\n\t\t\tconst res = await this.init();\n\t\t\tif (!res) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn this.increment(0, -1);\n\t}\n}\n", "import { BPTreeNode, MemoryPointer } from \"./node\";\nimport { RangeResolver } from \"../resolver\";\nimport { TraversalIterator, TraversalRecord } from \"./traversal\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { FieldType } from \"../db/database\";\n\nexport interface MetaPage {\n\troot(): Promise<MemoryPointer>;\n}\n\ntype RootResponse = {\n\trootNode: BPTreeNode | null;\n\tpointer: MemoryPointer;\n};\n\nexport class BPTree {\n\tprivate readonly tree: RangeResolver;\n\tprivate meta: MetaPage;\n\tprivate readonly dataFileResolver: RangeResolver;\n\tprivate fileFormat: FileFormat;\n\tprivate pageFieldType: FieldType;\n\n\tconstructor(\n\t\ttree: RangeResolver,\n\t\tmeta: MetaPage,\n\t\tdataFileResolver: RangeResolver,\n\t\tfileFormat: FileFormat,\n\t\tpageFieldType: FieldType\n\t) {\n\t\tthis.tree = tree;\n\t\tthis.meta = meta;\n\t\tthis.dataFileResolver = dataFileResolver;\n\t\tthis.fileFormat = fileFormat;\n\t\tthis.pageFieldType = pageFieldType;\n\t}\n\n\tasync root(): Promise<RootResponse> {\n\t\tconst mp = await this.meta.root();\n\n\t\tif (!mp || mp.length === 0) {\n\t\t\treturn {\n\t\t\t\trootNode: null,\n\t\t\t\tpointer: mp,\n\t\t\t};\n\t\t}\n\n\t\tconst root = await this.readNode(mp);\n\t\tif (!root) {\n\t\t\treturn {\n\t\t\t\trootNode: null,\n\t\t\t\tpointer: mp,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\trootNode: root,\n\t\t\tpointer: mp,\n\t\t};\n\t}\n\n\tasync readNode(ptr: MemoryPointer): Promise<BPTreeNode> {\n\t\ttry {\n\t\t\tconst { node, bytesRead } = await BPTreeNode.fromMemoryPointer(\n\t\t\t\tptr,\n\t\t\t\tthis.tree,\n\t\t\t\tthis.dataFileResolver,\n\t\t\t\tthis.fileFormat,\n\t\t\t\tthis.pageFieldType\n\t\t\t);\n\n\t\t\tif (!bytesRead) {\n\t\t\t\tthrow new Error(\"bytes read do not line up\");\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${error}`);\n\t\t}\n\t}\n\n\tpublic iter(key: ReferencedValue): TraversalIterator {\n\t\treturn new TraversalIterator(this, key);\n\t}\n\n\tasync traverse(\n\t\tkey: ReferencedValue,\n\t\tnode: BPTreeNode,\n\t\tpointer: MemoryPointer\n\t): Promise<TraversalRecord[]> {\n\t\tlet [index, found] = binarySearchReferencedValues(node.keys, key);\n\t\tif (node.leaf()) {\n\t\t\treturn [{ node, index, pointer }];\n\t\t}\n\n\t\tif (found) {\n\t\t\tindex += 1;\n\t\t}\n\n\t\tconst childPointer = node.pointer(index);\n\t\tconst child = await this.readNode(childPointer);\n\t\tconst path = await this.traverse(key, child, childPointer);\n\n\t\treturn [...path, { node, index, pointer }];\n\t}\n\n\tpublic async find(\n\t\tkey: ReferencedValue\n\t): Promise<[ReferencedValue, MemoryPointer]> {\n\t\tconst p = this.iter(key);\n\n\t\tif (!(await p.next())) {\n\t\t\treturn [\n\t\t\t\tnew ReferencedValue(\n\t\t\t\t\t{ offset: 0n, length: 0 },\n\t\t\t\t\tnew Uint8Array(0).buffer\n\t\t\t\t),\n\t\t\t\t{ offset: 0n, length: 0 },\n\t\t\t];\n\t\t}\n\n\t\treturn [p.getKey(), p.getPointer()];\n\t}\n}\n\nexport class ReferencedValue {\n\tpublic dataPointer: MemoryPointer;\n\tpublic value: ArrayBuffer;\n\n\tconstructor(dataPointer: MemoryPointer, value: ArrayBuffer) {\n\t\tthis.dataPointer = dataPointer;\n\t\tthis.value = value;\n\t}\n\n\tsetDataPointer(mp: MemoryPointer) {\n\t\tthis.dataPointer = mp;\n\t}\n\n\tsetValue(value: ArrayBuffer) {\n\t\tthis.value = value;\n\t}\n\n\tstatic compareBytes(aBuffer: ArrayBuffer, bBuffer: ArrayBuffer): number {\n\t\tconst a = new Uint8Array(aBuffer);\n\t\tconst b = new Uint8Array(bBuffer);\n\n\t\tconst len = Math.min(a.length, b.length);\n\t\tfor (let idx = 0; idx < len; idx++) {\n\t\t\tif (a[idx] !== b[idx]) {\n\t\t\t\treturn a[idx] < b[idx] ? -1 : 1;\n\t\t\t}\n\t\t}\n\n\t\tif (a.length < b.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a.length > b.length) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nfunction compareReferencedValues(\n\ta: ReferencedValue,\n\tb: ReferencedValue\n): number {\n\tconst valueComparison = ReferencedValue.compareBytes(a.value, b.value);\n\tif (valueComparison !== 0) {\n\t\treturn valueComparison;\n\t}\n\n\tif (a.dataPointer.offset > b.dataPointer.offset) {\n\t\treturn 1;\n\t} else if (a.dataPointer.offset < b.dataPointer.offset) {\n\t\treturn -1;\n\t}\n\n\tif (a.dataPointer.length > b.dataPointer.length) {\n\t\treturn 1;\n\t} else if (a.dataPointer.length < b.dataPointer.length) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nexport function binarySearchReferencedValues(\n\tvalues: ReferencedValue[],\n\ttarget: ReferencedValue\n): [number, boolean] {\n\tconst n = values.length;\n\n\tlet i = 0;\n\tlet j = n;\n\n\twhile (i < j) {\n\t\tconst h = Math.floor((i + j) / 2);\n\n\t\tif (compareReferencedValues(values[h], target) < 0) {\n\t\t\ti = h + 1;\n\t\t} else {\n\t\t\tj = h;\n\t\t}\n\t}\n\n\treturn [i, i < n && compareReferencedValues(values[i], target) === 0];\n}\n", "import { Database, OrderBy, Query, Schema, WhereNode } from \"./database\";\n\n/**\n * A class for building and executing database queries in a flexible API style.\n * Allows chaining methods for 'where', 'orderBy', 'select', and 'limit' clauses.\n */\nexport class QueryBuilder<T extends Schema> {\n\tprivate queryObject: Query<T> = {\n\t\twhere: [],\n\t\torderBy: undefined,\n\t\tselect: undefined,\n\t\tlimit: undefined,\n\t};\n\n\t/**\n\t * Initializes a new instance of the QueryBuilder class.\n\t * @param {Database<T>} database - An Appendable database instance to execute queries against.\n\t */\n\tconstructor(private database: Database<T>) {}\n\n\t/**\n\t * Retrieves an immutable copy of the current query.\n\t *\n\t * @returns {Query<T>} The Query instance.\n\t */\n\ttoQuery(): Query<T> {\n\t\treturn {\n\t\t\twhere: this.queryObject.where ? [...this.queryObject.where] : [],\n\t\t\torderBy: this.queryObject.orderBy\n\t\t\t\t? [...this.queryObject.orderBy]\n\t\t\t\t: undefined,\n\t\t\tselect: this.queryObject.select\n\t\t\t\t? [...this.queryObject.select]\n\t\t\t\t: undefined,\n\t\t\tlimit: this.queryObject.limit,\n\t\t};\n\t}\n\n\t/**\n\t * Executes the constructed query\n\t */\n\tget() {\n\t\t//return this.database.query(this.queryObject);\n\t}\n\n\t/**\n\t * Adds a 'where' clause to the query.\n\t *\n\t * @param {keyof T} key - The index header's field name to apply the 'where' condition.\n\t * @param {WhereNode<T>[\"operation\"]} operation - The comparison relation (e.g., >=, <=, ==, >=, >).\n\t * @param {T[keyof T]} value - The value to compare against.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\twhere(\n\t\tkey: keyof T,\n\t\toperation: WhereNode<T>[\"operation\"],\n\t\tvalue: T[keyof T]\n\t): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\twhere: [...(this.queryObject.where || []), { key, operation, value }],\n\t\t};\n\t\treturn newQuery;\n\t}\n\t/**\n\t * Adds an 'orderBy' clause to the query.\n\t *\n\t * @param {keyof T} key - The index header's field name to order by.\n\t * @param {OrderBy<T>[\"direction\"]} direction - The sorting direction (e.g., ASC, DESC).\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\torderBy(key: keyof T, direction: OrderBy<T>[\"direction\"]): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\torderBy: [...(this.queryObject.orderBy || []), { key, direction }],\n\t\t};\n\t\treturn newQuery;\n\t}\n\n\t/**\n\t * Specifies the fields to be selected in the query.\n\t *\n\t * @param {(keyof T)[]} keys - A list of index header field names.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\tselect(keys: (keyof T)[]): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\tselect: keys,\n\t\t};\n\t\treturn newQuery;\n\t}\n\n\t/**\n\t * Limits the number of records returned by the query.\n\t *\n\t * @param {number} limit - The maximum number of records to return.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\tlimit(limit: number): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\tlimit: limit,\n\t\t};\n\t\treturn newQuery;\n\t}\n}\n", "import { BPTree, ReferencedValue } from \"../btree/bptree\";\nimport { MemoryPointer } from \"../btree/node\";\nimport { DataFile } from \"../data-file\";\nimport { VersionedIndexFile } from \"../index-file/index-file\";\nimport { FileFormat, readIndexMeta } from \"../index-file/meta\";\nimport { QueryBuilder } from \"./query-builder\";\n\nexport type Schema = {\n\t[key: string]: {};\n};\n\nexport type WhereNode<T extends Schema, K extends keyof T = keyof T> = {\n\toperation: \"<\" | \"<=\" | \"==\" | \">=\" | \">\";\n\tkey: keyof T;\n\tvalue: T[K];\n};\n\nexport type OrderBy<T extends Schema> = {\n\tkey: keyof T;\n\tdirection: \"ASC\" | \"DESC\";\n};\n\nexport type SelectField<T extends Schema> = keyof T;\n\nexport type Query<T extends Schema> = {\n\twhere?: WhereNode<T>[];\n\torderBy?: OrderBy<T>[];\n\tselect?: SelectField<T>[];\n\tlimit?: number;\n};\n\nexport enum FieldType {\n\tString = 0,\n\tInt64 = 1,\n\tUint64 = 2,\n\tFloat64 = 3,\n\tObject = 4,\n\tArray = 5,\n\tBoolean = 6,\n\tNull = 7,\n}\n\nfunction parseIgnoringSuffix(\n\tx: string,\n\tformat: FileFormat,\n\theaderFields: string[]\n) {\n\tswitch (format) {\n\t\tcase FileFormat.JSONL:\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(x);\n\t\t\t} catch (error) {\n\t\t\t\tconst e = error as Error;\n\t\t\t\tlet m = e.message.match(/position\\s+(\\d+)/);\n\t\t\t\tif (m) {\n\t\t\t\t\tconsole.log(x.slice(0, Number(m[1])));\n\t\t\t\t\tx = x.slice(0, Number(m[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(JSON.parse(x));\n\t\t\treturn JSON.parse(x);\n\n\t\tcase FileFormat.CSV:\n\t\t\tconst fields = x.split(\",\");\n\n\t\t\tif (fields.length === 2) {\n\t\t\t\tx = fields[0];\n\t\t\t\treturn JSON.parse(x);\n\t\t\t} else {\n\t\t\t\tconst newlinePos = x.indexOf(\"\\n\");\n\t\t\t\tconst result = newlinePos !== -1 ? x.substring(0, newlinePos) : x;\n\t\t\t\tconst csvFields = result.split(\",\");\n\n\t\t\t\t// assert lengths are equal\n\t\t\t\tif (csvFields.length === headerFields.length) {\n\t\t\t\t\treturn buildJsonFromCsv(csvFields, headerFields);\n\t\t\t\t} else {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\nfunction buildJsonFromCsv(csvFields: string[], headerFields: string[]) {\n\treturn headerFields.reduce<{ [key: string]: string }>(\n\t\t(acc, header, index) => {\n\t\t\tacc[header] = csvFields[index];\n\t\t\treturn acc;\n\t\t},\n\t\t{}\n\t);\n}\n\nfunction fieldRank(token: any) {\n\tif (token === null) {\n\t\treturn 1;\n\t}\n\tif (typeof token === \"boolean\") {\n\t\treturn 2;\n\t}\n\tif (typeof token === \"number\" || typeof token === \"bigint\") {\n\t\treturn 3;\n\t}\n\tif (typeof token === \"string\") {\n\t\treturn 4;\n\t}\n\tthrow new Error(\"unknown type\");\n}\n\nfunction cmp(a: any, b: any) {\n\tconst atr = fieldRank(a);\n\tconst btr = fieldRank(b);\n\tif (atr !== btr) {\n\t\treturn atr - btr;\n\t}\n\tswitch (atr) {\n\t\tcase 1:\n\t\t\treturn 0;\n\t\tcase 2:\n\t\t\treturn a ? 1 : -1;\n\t\tcase 3:\n\t\t\treturn a - b;\n\t\tcase 4:\n\t\t\treturn a.localeCompare(b);\n\t\tdefault:\n\t\t\tthrow new Error(\"unknown type\");\n\t}\n}\n\nexport class Database<T extends Schema> {\n\tprivate constructor(\n\t\tprivate dataFile: DataFile,\n\t\tprivate indexFile: VersionedIndexFile<T>\n\t) {}\n\n\tstatic forDataFileAndIndexFile<T extends Schema>(\n\t\tdataFile: DataFile,\n\t\tindexFile: VersionedIndexFile<T>\n\t) {\n\t\treturn new Database(dataFile, indexFile);\n\t}\n\n\tasync fields() {\n\t\treturn await this.indexFile.indexHeaders();\n\t}\n\n\tasync *query(query: Query<T>) {\n\t\tif (new Set((query.where ?? []).map((where) => where.key)).size > 1) {\n\t\t\tthrow new Error(\"composite indexes not supported... yet\");\n\t\t}\n\n\t\tconst headers = await this.indexFile.indexHeaders();\n\n\t\tconst fieldRanges = await Promise.all(\n\t\t\t(query.where ?? []).map(async ({ key, value, operation }) => {\n\t\t\t\tconst header = headers.find((header) => header.fieldName === key);\n\t\t\t\tif (!header) {\n\t\t\t\t\tthrow new Error(\"field not found\");\n\t\t\t\t}\n\n\t\t\t\tlet valueBuf: ArrayBuffer;\n\t\t\t\tlet fieldType: number;\n\n\t\t\t\tif (key === null) {\n\t\t\t\t\tfieldType = FieldType.Null;\n\t\t\t\t\tvalueBuf = new ArrayBuffer(0);\n\t\t\t\t} else {\n\t\t\t\t\tswitch (typeof value) {\n\t\t\t\t\t\tcase \"bigint\":\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\tfieldType = FieldType.Float64;\n\t\t\t\t\t\t\tvalueBuf = new ArrayBuffer(8);\n\t\t\t\t\t\t\tnew DataView(valueBuf).setFloat64(0, Number(value), true);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\tfieldType = FieldType.Boolean;\n\t\t\t\t\t\t\tvalueBuf = new ArrayBuffer(1);\n\t\t\t\t\t\t\tnew DataView(valueBuf).setUint8(0, value ? 1 : 0);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\t\tfieldType = FieldType.String;\n\t\t\t\t\t\t\tvalueBuf = new TextEncoder().encode(value as string).buffer;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(\"unmatched key type\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst mps = await this.indexFile.seek(key as string, fieldType);\n\t\t\t\tconst rangeMemoryPointers = [];\n\n\t\t\t\tconst mp = mps[0];\n\n\t\t\t\tconst dfResolver = this.dataFile.getResolver();\n\n\t\t\t\tif (dfResolver === undefined) {\n\t\t\t\t\tthrow new Error(\"data file is undefined\");\n\t\t\t\t}\n\n\t\t\t\tconst valueRef = new ReferencedValue(\n\t\t\t\t\t{ offset: 0n, length: 0 },\n\t\t\t\t\tvalueBuf\n\t\t\t\t);\n\n\t\t\t\tconst { format } = await this.indexFile.metadata();\n\t\t\t\tconst { fieldType: mpFieldType } = await readIndexMeta(\n\t\t\t\t\tawait mp.metadata()\n\t\t\t\t);\n\n\t\t\t\tconst bptree = new BPTree(\n\t\t\t\t\tthis.indexFile.getResolver(),\n\t\t\t\t\tmp,\n\t\t\t\t\tdfResolver,\n\t\t\t\t\tformat,\n\t\t\t\t\tmpFieldType\n\t\t\t\t);\n\n\t\t\t\tlet memoryPointers: MemoryPointer[] = [];\n\n\t\t\t\tif (operation === \"<\" || operation === \"<=\" || operation === \"==\") {\n\t\t\t\t}\n\n\t\t\t\t// memoryPointers = memoryPointers.reverse();\n\n\t\t\t\tconst unique = new Set();\n\n\t\t\t\tif (operation === \">\" || operation === \">=\" || operation === \"==\") {\n\t\t\t\t\tconst iter = bptree.iter(valueRef);\n\n\t\t\t\t\twhile (await iter.next()) {\n\t\t\t\t\t\tconst currentKey = iter.getKey();\n\n\t\t\t\t\t\tif (ReferencedValue.compareBytes(valueBuf, currentKey.value) === 0) {\n\t\t\t\t\t\t\tif (unique.has(currentKey.dataPointer.offset)) {\n\t\t\t\t\t\t\t\tconsole.log(\"not unique\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tunique.add(currentKey.dataPointer.offset);\n\t\t\t\t\t\t\tconsole.log(\"equal\")\n\n\t\t\t\t\t\t\tmemoryPointers.push(currentKey.dataPointer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trangeMemoryPointers.push(...memoryPointers);\n\t\t\t\tconsole.log(rangeMemoryPointers);\n\t\t\t\treturn [key, rangeMemoryPointers] as [keyof T, MemoryPointer[]];\n\t\t\t})\n\t\t);\n\n\t\tconsole.log(\"field ranges\");\n\n\t\tfor (const [key, mps] of fieldRanges) {\n\t\t\tfor (const { offset, length } of mps) {\n\t\t\t\tconst data = await this.dataFile.get(\n\t\t\t\t\tNumber(offset),\n\t\t\t\t\tNumber(offset) + length - 1\n\t\t\t\t);\n\t\t\t\tconsole.log(data);\n\t\t\t\tyield data;\n\t\t\t}\n\t\t}\n\t}\n\n\t// async *queryV2(query: Query<T>) {\n\t// \t// group the field ranges by the field name and merge them into single ranges.\n\t// \tconst fieldRangeMap = new Map<keyof T, [number, number]>();\n\n\t// \tfor (const [key, value] of fieldRanges) {\n\t// \t\tconst existing = fieldRangeMap.get(key);\n\t// \t\tif (existing) {\n\t// \t\t\tfieldRangeMap.set(key, [\n\t// \t\t\t\tMath.max(existing[0], value[0]),\n\t// \t\t\t\tMath.min(existing[1], value[1]),\n\t// \t\t\t]);\n\t// \t\t} else {\n\t// \t\t\tfieldRangeMap.set(key, value);\n\t// \t\t}\n\t// \t}\n\t// \t// sort the field ranges by size.\n\t// \tconst fieldRangesSorted = [...fieldRangeMap.entries()].sort(\n\t// \t\t(a, b) => a[1][1] - a[1][0] - (b[1][1] - b[1][0])\n\t// \t);\n\t// \t// move the order by fields to the front of the field ranges.\n\t// \tconst orderByFields = (query.orderBy ?? []).map((orderBy) => orderBy.key);\n\t// \tfor (const orderByField of orderByFields) {\n\t// \t\tconst index = fieldRangesSorted.findIndex(\n\t// \t\t\t(fieldRange) => fieldRange[0] === orderByField\n\t// \t\t);\n\t// \t\tif (index >= 0) {\n\t// \t\t\tfieldRangesSorted.unshift(...fieldRangesSorted.splice(index, 1));\n\t// \t\t}\n\t// \t}\n\n\t// \t// evaluate the field ranges in order.\n\t// \tfor (const [key, [start, end]] of fieldRangesSorted) {\n\t// \t\t// check if the iteration order should be reversed.\n\t// \t\tconst orderBy = query.orderBy?.find((orderBy) => orderBy.key === key);\n\t// \t\tconst reverse = orderBy?.direction === \"DESC\";\n\t// \t\tconst length = end - start;\n\t// \t\tfor (let offset = 0; offset < length; offset++) {\n\t// \t\t\tconst index = reverse ? end - offset - 1 : start + offset;\n\t// \t\t\tconst indexRecord = await this.indexFile.indexRecord(key, index);\n\t// \t\t\tconst dataRecord = await this.indexFile.dataRecord(\n\t// \t\t\t\tindexRecord.dataNumber\n\t// \t\t\t);\n\n\t// \t\t\tconsole.log(`Data record: `, dataRecord);\n\t// \t\t\tconst parsedFieldValue = parseIgnoringSuffix(\n\t// \t\t\t\tawait this.dataFile.get(\n\t// \t\t\t\t\tdataRecord.startByteOffset,\n\t// \t\t\t\t\tdataRecord.endByteOffset\n\t// \t\t\t\t),\n\t// \t\t\t\tthis.formatType,\n\t// \t\t\t\theaderFields\n\t// \t\t\t);\n\n\t// \t\t\tlet dataFieldValue = parsedFieldValue;\n\n\t// \t\t\tif (query.select && query.select.length > 0) {\n\t// \t\t\t\tif (\n\t// \t\t\t\t\ttypeof parsedFieldValue === \"object\" &&\n\t// \t\t\t\t\tparsedFieldValue !== null\n\t// \t\t\t\t) {\n\t// \t\t\t\t\tdataFieldValue = query.select.reduce(\n\t// \t\t\t\t\t\t(acc, field) => {\n\t// \t\t\t\t\t\t\tif (field in parsedFieldValue) {\n\t// \t\t\t\t\t\t\t\tacc[field] = parsedFieldValue[field];\n\t// \t\t\t\t\t\t\t}\n\t// \t\t\t\t\t\t\treturn acc;\n\t// \t\t\t\t\t\t},\n\t// \t\t\t\t\t\t{} as Pick<T, keyof T>\n\t// \t\t\t\t\t);\n\t// \t\t\t\t}\n\t// \t\t\t}\n\n\t// \t\t\tyield dataFieldValue;\n\t// \t\t}\n\t// \t}\n\t// }\n\n\twhere(\n\t\tkey: keyof T,\n\t\toperation: WhereNode<T>[\"operation\"],\n\t\tvalue: T[keyof T]\n\t): QueryBuilder<T> {\n\t\treturn new QueryBuilder(this).where(key, operation, value);\n\t}\n}\n", "import { RangeResolver } from \"../resolver\";\nimport { MemoryPointer } from \"./node\";\nimport { PageFile } from \"./pagefile\";\n\nconst PAGE_SIZE_BYTES = 4096;\nexport const maxUint64 = 2n ** 64n - 1n;\n\nexport class LinkedMetaPage {\n\tprivate resolver: RangeResolver;\n\tprivate offset: bigint;\n\tprivate metaPageData: ArrayBuffer | null;\n\tprivate metaPagePromise: Promise<ArrayBuffer> | null = null;\n\n\tconstructor(resolver: RangeResolver, offset: bigint) {\n\t\tthis.resolver = resolver;\n\t\tthis.offset = offset;\n\t\tthis.metaPageData = null;\n\t}\n\n\tasync root(): Promise<MemoryPointer> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\t// we seek by 12 bytes since offset is 8 bytes, length is 4 bytes\n\t\tconst data = pageData.slice(0, 12);\n\t\tconst view = new DataView(data);\n\n\t\tconst pointerOffset = view.getBigUint64(0);\n\t\tconst lengthOffset = view.getUint32(8);\n\n\t\treturn {\n\t\t\toffset: pointerOffset,\n\t\t\tlength: lengthOffset,\n\t\t};\n\t}\n\n\t/**\n\t * `metadata()` gets the page data. It does the following:\n\t * \t\t(1) creates a slice from 24 to the end of the page\n\t * \t\t(2) it reads the first four bytes of that slice which gives us the length to seek to\n\t * \t\t(3) slices from [24, (24 + dataLength)] which contain metadata\n\t */\n\tasync metadata(): Promise<ArrayBuffer> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\tconst lengthView = new DataView(pageData, 24);\n\n\t\t// read the first four because that represents length\n\t\tconst metadataLength = lengthView.getUint32(0);\n\n\t\treturn pageData.slice(28, 28 + metadataLength);\n\t}\n\n\t/**\n\t * `getMetaPage()` seeks the index-file with the absolute bounds for a given page file.\n\t * It caches the data in a pagefile. Note: all other methods that call this should be slicing with relative bounds.\n\t */\n\tprivate async getMetaPage(): Promise<ArrayBuffer> {\n\t\tif (this.metaPageData) {\n\t\t\treturn this.metaPageData;\n\t\t}\n\n\t\tif (!this.metaPagePromise) {\n\t\t\tthis.metaPagePromise = this.resolver({\n\t\t\t\tstart: Number(this.offset),\n\t\t\t\tend: Number(this.offset) + PAGE_SIZE_BYTES - 1,\n\t\t\t})\n\t\t\t\t.then(({ data }) => {\n\t\t\t\t\tthis.metaPageData = data;\n\t\t\t\t\tthis.metaPagePromise = null;\n\t\t\t\t\treturn data;\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tthis.metaPagePromise = null;\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this.metaPagePromise;\n\t}\n\n\t/**\n\t * `next()` - returns a new LinkedMetaPage\n\t */\n\tasync next(): Promise<LinkedMetaPage | null> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\tconst view = new DataView(pageData, 12, 8);\n\t\tconst nextOffset = view.getBigUint64(0);\n\n\t\tif (nextOffset === maxUint64) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new LinkedMetaPage(this.resolver, nextOffset);\n\t}\n\n\tgetOffset(): bigint {\n\t\treturn this.offset;\n\t}\n}\n\nexport function ReadMultiBPTree(\n\tresolver: RangeResolver,\n\tpageFile: PageFile\n): LinkedMetaPage {\n\tconst offset = pageFile.page(0);\n\treturn new LinkedMetaPage(resolver, offset);\n}\n", "/**\n * RangeResolver is a function that takes a range of bytes and returns a promise\n * that resolves to an ArrayBuffer containing the bytes in that range. Note that\n * the range is inclusive.\n *\n * Additionally, the RangeResolver must return a checksum which is computed from\n * the source data. This checksum is used to verify that the data has not been\n * changed between requests. The checksum can be any type, for example it is\n * valid to use the last modified timestamp of the source data or the total\n * length of the data. This checksum is passed to the RangeResolver on future\n * requests as the `checksum` argument. If it does not match the checksum when\n * reading the data, the RangeResolver should throw a LengthIntegrityError.\n *\n * @see LengthIntegrityError\n */\nexport type RangeResolver = (args: {\n\tstart: number;\n\tend: number;\n\texpectedLength?: number;\n}) => Promise<{\n\tdata: ArrayBuffer;\n\ttotalLength: number;\n}>;\n\n/**\n * LengthIntegrityError is thrown by a RangeResolver when the length argument is\n * inconsistent with the data returned. This is used to detect when the data has\n * changed between requests.\n *\n * When a LengthIntegrityError is thrown, typically the cache is evicted and the\n * query will be tried again with the exception of the data file where the error\n * is ignored due to the assumed immutability of the data file.\n *\n * @see RangeResolver\n */\nexport class LengthIntegrityError extends Error {\n\tconstructor() {\n\t\tsuper(\"length integrity error\");\n\t}\n}\n", "import {RangeResolver} from \"../resolver\";\n\nconst pageSizeBytes = 4096;\n\nexport class PageFile {\n\n    private resolver: RangeResolver;\n    private pageSize: number = pageSizeBytes;\n\n    constructor(resolver: RangeResolver) {\n        this.resolver = resolver;\n    }\n\n    async readPage(idx: number): Promise<ArrayBuffer> {\n        if(idx < 0) {\n            throw new Error(\"page cannot be indexed\");\n        }\n\n        const start = (idx + 1) * this.pageSize;\n        const end = start + this.pageSize - 1;\n\n        const { data } = await this.resolver({ start, end: end - 1 });\n\n        return data;\n    }\n\n    page(idx: number): bigint {\n        if (idx < 0) {\n            return BigInt(0);\n        }\n\n        return BigInt(idx + 1) * BigInt(this.pageSize);\n    }\n}\n", "import { LinkedMetaPage, ReadMultiBPTree } from \"../btree/multi\";\nimport { LengthIntegrityError, RangeResolver } from \"../resolver\";\nimport { PageFile } from \"../btree/pagefile\";\nimport {\n\tFileFormat,\n\tIndexHeader,\n\tIndexMeta,\n\tcollectIndexMetas,\n\treadIndexMeta,\n} from \"./meta\";\nimport { FieldType } from \"../db/database\";\n\nexport class IndexFile {\n\tstatic async forUrl<T = any>(url: string) {\n\t\treturn await IndexFile.forResolver<T>(\n\t\t\tasync ({ start, end, expectedLength }) => {\n\t\t\t\tconst response = await fetch(url, {\n\t\t\t\t\theaders: { Range: `bytes=${start}-${end}` },\n\t\t\t\t});\n\t\t\t\tconst totalLength = Number(\n\t\t\t\t\tresponse.headers.get(\"Content-Range\")!.split(\"/\")[1]\n\t\t\t\t);\n\t\t\t\tif (expectedLength && totalLength !== expectedLength) {\n\t\t\t\t\tthrow new LengthIntegrityError();\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdata: await response.arrayBuffer(),\n\t\t\t\t\ttotalLength: totalLength,\n\t\t\t\t};\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic async forResolver<T = any>(\n\t\tresolver: RangeResolver\n\t): Promise<VersionedIndexFile<T>> {\n\t\treturn new IndexFileV1<T>(resolver);\n\t}\n}\n\nfunction decodeFloatingInt16(x: number) {\n\tconst exponent = x >> 11;\n\tconst mantissa = x & 0x7ff;\n\treturn (1 << exponent) * mantissa + (1 << (exponent + 11)) - (1 << 11);\n}\n\nexport type FileMeta = {\n\tversion: number;\n\tformat: number;\n\treadOffset: bigint;\n};\n\nexport interface VersionedIndexFile<T> {\n\tgetResolver(): RangeResolver;\n\n\ttree(): Promise<LinkedMetaPage>;\n\n\tmetadata(): Promise<FileMeta>;\n\n\tindexHeaders(): Promise<IndexHeader[]>;\n\n\tseek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]>;\n}\n\nexport class IndexFileV1<T> implements VersionedIndexFile<T> {\n\tprivate _tree?: LinkedMetaPage;\n\n\tconstructor(private resolver: RangeResolver) {}\n\n\tgetResolver(): RangeResolver {\n\t\treturn this.resolver;\n\t}\n\n\tasync tree(): Promise<LinkedMetaPage> {\n\t\tif (this._tree) {\n\t\t\treturn this._tree;\n\t\t}\n\n\t\tconst pageFile = new PageFile(this.resolver);\n\t\tconst tree = ReadMultiBPTree(this.resolver, pageFile);\n\n\t\tthis._tree = tree;\n\t\treturn tree;\n\t}\n\n\tasync metadata(): Promise<FileMeta> {\n\t\tconst tree = await this.tree();\n\n\t\tconst buffer = await tree.metadata();\n\n\t\t// unmarshall binary for FileMeta\n\t\tif (buffer.byteLength < 10) {\n\t\t\tthrow new Error(\n\t\t\t\t`incorrect byte length! Want: 10, got ${buffer.byteLength}`\n\t\t\t);\n\t\t}\n\n\t\tconst dataView = new DataView(buffer);\n\t\tconst version = dataView.getUint8(0);\n\t\tconst formatByte = dataView.getUint8(1);\n\n\t\tif (Object.values(FileFormat).indexOf(formatByte) === -1) {\n\t\t\tthrow new Error(`unexpected file format. Got: ${formatByte}`);\n\t\t}\n\n\t\tconst readOffset = dataView.getBigUint64(2);\n\n\t\treturn {\n\t\t\tversion: version,\n\t\t\tformat: formatByte,\n\t\t\treadOffset: readOffset,\n\t\t};\n\t}\n\n\tasync seek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]> {\n\t\tlet mp = await this.tree();\n\n\t\tlet headerMps = [];\n\n\t\twhile (mp) {\n\t\t\tconst next = await mp.next();\n\t\t\tif (next === null) {\n\t\t\t\treturn headerMps;\n\t\t\t}\n\n\t\t\tconst indexMeta = await readIndexMeta(await next.metadata());\n\t\t\tif (indexMeta.fieldName === header) {\n\t\t\t\tif (fieldType === FieldType.Float64) {\n\t\t\t\t\t// if key is a number or bigint, we cast it as a float64 type\n\t\t\t\t\tif (\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Float64 ||\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Int64 ||\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Uint64\n\t\t\t\t\t) {\n\t\t\t\t\t\theaderMps.push(next);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (indexMeta.fieldType === fieldType) {\n\t\t\t\t\t\theaderMps.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmp = next;\n\t\t}\n\t\tconsole.log(headerMps);\n\n\t\treturn headerMps;\n\t}\n\n\tasync indexHeaders(): Promise<IndexHeader[]> {\n\t\tlet headers: IndexMeta[] = [];\n\n\t\tlet mp = await this.tree();\n\n\t\twhile (mp) {\n\t\t\tconst next = await mp.next();\n\t\t\tif (next === null) {\n\t\t\t\treturn collectIndexMetas(headers);\n\t\t\t}\n\n\t\t\tconst nextBuffer = await next.metadata();\n\t\t\tconst indexMeta = await readIndexMeta(nextBuffer);\n\n\t\t\theaders.push(indexMeta);\n\n\t\t\tmp = next;\n\t\t}\n\n\t\treturn collectIndexMetas(headers);\n\t}\n}\n", "import { DataFile } from \"./data-file\";\nimport { Database, FieldType } from \"./db/database\";\nimport { IndexFile } from \"./index-file/index-file\";\nimport { RangeResolver } from \"./resolver\";\n\nexport async function init(\n\tdataUrl: string | RangeResolver,\n\tindexUrl: string | RangeResolver\n) {\n\treturn Database.forDataFileAndIndexFile(\n\t\ttypeof dataUrl === \"string\"\n\t\t\t? DataFile.forUrl(dataUrl)\n\t\t\t: DataFile.forResolver(dataUrl),\n\t\ttypeof indexUrl === \"string\"\n\t\t\t? await IndexFile.forUrl(indexUrl)\n\t\t\t: await IndexFile.forResolver(indexUrl)\n\t);\n}\n\ninterface GlobalMap {\n\tAppendable: {\n\t\tinit: Function;\n\t\tFieldType: typeof FieldType;\n\t};\n}\n\ndeclare global {\n\tvar Appendable: GlobalMap[\"Appendable\"];\n}\n\nglobalThis.Appendable = {\n\tinit,\n\tFieldType,\n};\n"],
  "mappings": "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",
  "names": ["DataFile", "_DataFile", "resolver", "url", "start", "end", "response", "totalLength", "instance", "expectedLength", "startByteOffset", "endByteOffset", "data", "FileFormat", "readIndexMeta", "buffer", "dataView", "fieldType", "nameLength", "fieldNameBuffer", "collectIndexMetas", "indexMetas", "headersMap", "meta", "updatedTypes", "indexHeaders", "fieldTypes", "fieldName", "BPTreeNode", "_BPTreeNode", "keys", "leafPointers", "internalPointers", "dataFileResolver", "fileFormat", "pageFieldType", "i", "size", "idx", "k", "buffer", "dataView", "ReferencedValue", "m", "dpOffset", "dpLength", "dp", "data", "parsedData", "value", "incomingData", "stringData", "jValue", "boolBuf", "floatBuf", "mp", "resolver", "dataFilePointer", "bufferData", "node", "TraversalIterator", "tree", "key", "rootResponse", "root", "offset", "path", "i", "delta", "rolloverLeft", "rolloverRight", "node", "BPTree", "tree", "meta", "dataFileResolver", "fileFormat", "pageFieldType", "mp", "root", "ptr", "node", "bytesRead", "BPTreeNode", "error", "key", "TraversalIterator", "pointer", "index", "found", "binarySearchReferencedValues", "childPointer", "child", "p", "ReferencedValue", "dataPointer", "value", "aBuffer", "bBuffer", "a", "b", "len", "idx", "compareReferencedValues", "valueComparison", "values", "target", "n", "i", "j", "h", "QueryBuilder", "_QueryBuilder", "database", "key", "operation", "value", "newQuery", "direction", "keys", "limit", "FieldType", "Database", "_Database", "dataFile", "indexFile", "query", "where", "headers", "fieldRanges", "key", "value", "operation", "header", "valueBuf", "fieldType", "mps", "rangeMemoryPointers", "mp", "dfResolver", "valueRef", "ReferencedValue", "format", "mpFieldType", "readIndexMeta", "bptree", "BPTree", "memoryPointers", "unique", "iter", "currentKey", "offset", "length", "data", "QueryBuilder", "PAGE_SIZE_BYTES", "maxUint64", "LinkedMetaPage", "_LinkedMetaPage", "resolver", "offset", "data", "view", "pointerOffset", "lengthOffset", "pageData", "metadataLength", "error", "nextOffset", "ReadMultiBPTree", "pageFile", "LengthIntegrityError", "pageSizeBytes", "PageFile", "resolver", "idx", "start", "end", "data", "IndexFile", "_IndexFile", "url", "start", "end", "expectedLength", "response", "totalLength", "LengthIntegrityError", "resolver", "IndexFileV1", "IndexFileV1", "resolver", "pageFile", "PageFile", "tree", "ReadMultiBPTree", "buffer", "dataView", "version", "formatByte", "FileFormat", "readOffset", "header", "fieldType", "mp", "headerMps", "next", "indexMeta", "readIndexMeta", "headers", "collectIndexMetas", "nextBuffer", "init", "dataUrl", "indexUrl", "Database", "DataFile", "IndexFile", "FieldType"]
}
