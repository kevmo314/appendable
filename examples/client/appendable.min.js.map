{
  "version": 3,
  "sources": ["../src/data-file.ts", "../src/index-file/meta.ts", "../src/btree/node.ts", "../src/btree/traversal.ts", "../src/btree/multi.ts", "../src/btree/bptree.ts", "../src/db/query-builder.ts", "../src/db/query-logic.ts", "../src/db/database.ts", "../src/resolver.ts", "../src/btree/pagefile.ts", "../src/index-file/index-file.ts", "../src/index.ts"],
  "sourcesContent": ["import { RangeResolver } from \"./resolver\";\n\nexport class DataFile {\n\tprivate originalResolver?: RangeResolver;\n\n\tprivate constructor(\n\t\tprivate resolver: (\n\t\t\tstart: number,\n\t\t\tend: number,\n\t\t\texpectedLength?: number\n\t\t) => Promise<ArrayBuffer>\n\t) {}\n\n\tstatic forUrl(url: string) {\n\t\treturn DataFile.forResolver(async ({ start, end }) => {\n\t\t\tconst response = await fetch(url, {\n\t\t\t\theaders: { Range: `bytes=${start}-${end}` },\n\t\t\t});\n\t\t\tconst totalLength = Number(\n\t\t\t\tresponse.headers.get(\"Content-Range\")!.split(\"/\")[1]\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tdata: await response.arrayBuffer(),\n\t\t\t\ttotalLength: totalLength,\n\t\t\t};\n\t\t});\n\t}\n\n\tstatic forResolver(resolver: RangeResolver) {\n\t\tconst instance = new DataFile(async (start, end, expectedLength?) => {\n\t\t\tconst result = await resolver({ start, end, expectedLength });\n\t\t\treturn result.data;\n\t\t});\n\t\tinstance.originalResolver = resolver; \n\t\treturn instance;\n  }\n  \n  getResolver(): RangeResolver | undefined {\n    return this.originalResolver;\n}\n\n\tasync get(startByteOffset: number, endByteOffset: number) {\n\t\tconst data = await this.resolver(startByteOffset, endByteOffset);\n\t\treturn new TextDecoder().decode(data);\n\t}\n}\n", "\nexport enum FileFormat {\n\tJSONL = 0,\n\tCSV = 1,\n}\n\nexport type FileMeta = {\n\tversion: number;\n\tformat: FileFormat;\n\treadOffset: bigint;\n};\n\nexport async function readFileMeta(buffer: ArrayBuffer): Promise<FileMeta> {\n\tif (buffer.byteLength !== 10) {\n\t\tthrow new Error(\n\t\t\t`incorrect byte length! Want: 10, got ${buffer.byteLength}`\n\t\t);\n\t}\n\n\tconst dataView = new DataView(buffer);\n\n\tconst version = dataView.getUint8(0);\n\tconst formatByte = dataView.getUint8(1);\n\n\tif (Object.values(FileFormat).indexOf(formatByte) === -1) {\n\t\tthrow new Error(`unexpected file format. Got: ${formatByte}`);\n\t}\n\n\n\tconst readOffset = dataView.getBigUint64(2);\n\n\treturn {\n\t\tversion,\n\t\tformat: formatByte,\n\t\treadOffset,\n\t};\n}\n\nexport type IndexMeta = {\n\tfieldName: string;\n\tfieldType: number;\n};\n\nexport type IndexHeader = {\n\tfieldName: string;\n\tfieldTypes: number[];\n}\n\nexport async function readIndexMeta(\n\tbuffer: ArrayBuffer,\n): Promise<IndexMeta> {\n\tif (buffer.byteLength < 4) {\n\t\tthrow new Error(`invalid metadata size ${buffer.byteLength}`);\n\t}\n\n\tconst dataView = new DataView(buffer);\n\tconst fieldType = dataView.getUint16(0);\n\tconst nameLength = dataView.getUint16(2);\n\n\tif (buffer.byteLength < 4 + nameLength) {\n\t\tthrow new Error(`invalid metadata size ${buffer.byteLength}`);\n\t}\n\n\tconst fieldNameBuffer = buffer.slice(4, 4+ nameLength);\n    const fieldName = new TextDecoder(\"utf-8\").decode(fieldNameBuffer);\n\n\treturn {\n\t\tfieldName,\n\t\tfieldType,\n\t};\n}\n\nexport function collectIndexMetas(indexMetas: IndexMeta[]): IndexHeader[] {\n    const headersMap: Map<string, number[]> = new Map();\n\n    for (const meta of indexMetas) {\n        if (!headersMap.has(meta.fieldName)) {\n            headersMap.set(meta.fieldName, [meta.fieldType]);\n        } else {\n            const updatedTypes = headersMap.get(meta.fieldName);\n            updatedTypes?.push(meta.fieldType);\n            headersMap.set(meta.fieldName, updatedTypes!!);\n        }\n    }\n\n    const indexHeaders: IndexHeader[] = [];\n    headersMap.forEach((fieldTypes, fieldName) => {\n        indexHeaders.push({ fieldName, fieldTypes });\n    });\n\n    return indexHeaders;\n}", "import { FieldType } from \"../db/database\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { RangeResolver } from \"../resolver\";\nimport { ReferencedValue } from \"./bptree\";\n\nexport const pageSizeBytes = 4096;\n\nexport type MemoryPointer = { offset: bigint; length: number };\nexport class BPTreeNode {\n\tpublic keys: ReferencedValue[];\n\tpublic leafPointers: MemoryPointer[];\n\tpublic internalPointers: bigint[];\n\tprivate readonly dataFileResolver: RangeResolver;\n\tprivate fileFormat: FileFormat;\n\tprivate pageFieldType: FieldType;\n\n\tconstructor(\n\t\tkeys: ReferencedValue[],\n\t\tleafPointers: MemoryPointer[],\n\t\tinternalPointers: bigint[],\n\t\tdataFileResolver: RangeResolver,\n\t\tfileFormat: FileFormat,\n\t\tpageFieldType: FieldType\n\t) {\n\t\tthis.keys = keys;\n\t\tthis.leafPointers = leafPointers;\n\t\tthis.internalPointers = internalPointers;\n\t\tthis.dataFileResolver = dataFileResolver;\n\t\tthis.fileFormat = fileFormat;\n\t\tthis.pageFieldType = pageFieldType;\n\t}\n\n\tleaf(): boolean {\n\t\treturn this.leafPointers.length > 0;\n\t}\n\n\tpointer(i: number): MemoryPointer {\n\t\tif (this.leaf()) {\n\t\t\treturn this.leafPointers[i];\n\t\t}\n\n\t\treturn {\n\t\t\toffset: this.internalPointers[i],\n\t\t\tlength: 0, // disregard since this is a free value in golang version\n\t\t};\n\t}\n\n\tnumPointers(): number {\n\t\treturn this.internalPointers.length + this.leafPointers.length;\n\t}\n\n\tsize(): bigint {\n\t\tlet size = 4;\n\n\t\tfor (let idx = 0; idx <= this.keys.length - 1; idx++) {\n\t\t\tconst k = this.keys[idx];\n\t\t\tif (k.dataPointer.length > 0) {\n\t\t\t\tsize += 4 + 12;\n\t\t\t} else {\n\t\t\t\tsize += 4 * k.value.byteLength;\n\t\t\t}\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n\t\t\tsize += 12;\n\t\t}\n\t\tfor (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n\t\t\tsize += 8;\n\t\t}\n\n\t\treturn BigInt(size);\n\t}\n\n\tasync unmarshalBinary(buffer: ArrayBuffer) {\n\t\tlet dataView = new DataView(buffer);\n\t\tlet size = dataView.getUint32(0);\n\n\t\tif (size > 2147483647) {\n\t\t\tsize = size - 4294967296;\n\t\t}\n\n\t\tconst leaf = size < 0;\n\n\t\tif (leaf) {\n\t\t\tthis.leafPointers = new Array<MemoryPointer>(-size)\n\t\t\t\t.fill({ offset: 0n, length: 0 })\n\t\t\t\t.map(() => ({\n\t\t\t\t\toffset: 0n,\n\t\t\t\t\tlength: 0,\n\t\t\t\t}));\n\t\t\tthis.keys = new Array(-size)\n\t\t\t\t.fill(null)\n\t\t\t\t.map(\n\t\t\t\t\t() =>\n\t\t\t\t\t\tnew ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0))\n\t\t\t\t);\n\t\t} else {\n\t\t\tthis.internalPointers = Array<bigint>(size + 1)\n\t\t\t\t.fill(0n)\n\t\t\t\t.map(() => 0n);\n\t\t\tthis.keys = new Array(size)\n\t\t\t\t.fill(null)\n\t\t\t\t.map(\n\t\t\t\t\t() =>\n\t\t\t\t\t\tnew ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0))\n\t\t\t\t);\n\t\t}\n\n\t\tif (size === 0) {\n\t\t\tthrow new Error(\"empty node\");\n\t\t}\n\n\t\tlet m = 4;\n\t\tfor (let idx = 0; idx <= this.keys.length - 1; idx++) {\n\t\t\t// this is the case when we store the pointer to the datafile\n\t\t\tdataView = new DataView(buffer, m, 4);\n\t\t\tconst l = dataView.getUint32(0);\n\t\t\tif (l === ~0 >>> 0) {\n\t\t\t\tdataView = new DataView(buffer, m + 4);\n\t\t\t\tconst dpOffset = dataView.getBigUint64(0);\n\t\t\t\tconst dpLength = dataView.getUint32(8);\n\t\t\t\tthis.keys[idx].setDataPointer({ offset: dpOffset, length: dpLength });\n\n\t\t\t\tconst dp = this.keys[idx].dataPointer;\n\n\t\t\t\tconst { data } = await this.dataFileResolver({\n\t\t\t\t\tstart: Number(dp.offset),\n\t\t\t\t\tend: Number(dp.offset) + dp.length - 1,\n\t\t\t\t});\n\n\t\t\t\tconst parsedData = this.parseValue(data);\n\n\t\t\t\tthis.keys[idx].setValue(parsedData);\n\t\t\t\tm += 4 + 12;\n\t\t\t} else {\n\t\t\t\t// we are storing the values directly in the referenced value\n\t\t\t\tconst value = buffer.slice(m + 4, m + 4 + l);\n\t\t\t\tthis.keys[idx].setValue(value);\n\t\t\t\tm += 4 + l;\n\t\t\t}\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n\t\t\tdataView = new DataView(buffer, m);\n\t\t\tthis.leafPointers[idx].offset = dataView.getBigUint64(0);\n\t\t\tthis.leafPointers[idx].length = dataView.getUint32(8);\n\n\t\t\tm += 12;\n\t\t}\n\n\t\tfor (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n\t\t\tdataView = new DataView(buffer, m);\n\t\t\tthis.internalPointers[idx] = dataView.getBigUint64(0);\n\n\t\t\tm += 8;\n\t\t}\n\t}\n\n\tparseValue(incomingData: ArrayBuffer): ArrayBuffer {\n\t\tconst stringData = new TextDecoder().decode(incomingData);\n\n\t\tswitch (this.fileFormat) {\n\t\t\tcase FileFormat.JSONL:\n\t\t\t\tconst jValue = JSON.parse(stringData);\n\n\t\t\t\tswitch (this.pageFieldType) {\n\t\t\t\t\tcase FieldType.Null:\n\t\t\t\t\t\tif (jValue !== null) {\n\t\t\t\t\t\t\tthrow new Error(`unrecognized value for null type: ${jValue}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new ArrayBuffer(0);\n\n\t\t\t\t\tcase FieldType.Boolean:\n\t\t\t\t\t\treturn new Uint8Array([jValue ? 1 : 0]).buffer;\n\n\t\t\t\t\tcase FieldType.Float64:\n\t\t\t\t\tcase FieldType.Int64:\n\t\t\t\t\tcase FieldType.Uint64:\n\t\t\t\t\t\tconst floatBuf = new ArrayBuffer(8);\n\t\t\t\t\t\tlet floatBufView = new DataView(floatBuf);\n\t\t\t\t\t\tfloatBufView.setFloat64(0, jValue, true);\n\n\t\t\t\t\t\treturn floatBuf;\n\n\t\t\t\t\tcase FieldType.String:\n\t\t\t\t\t\tconst e = new TextEncoder().encode(jValue);\n\t\t\t\t\t\treturn e.buffer;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unexpected Field Type. Got: ${this.pageFieldType}`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\tcase FileFormat.CSV:\n\t\t\t\treturn incomingData;\n\t\t}\n\n\t\tthrow new Error(\"unexpected parsing error occured\");\n\t}\n\n\tstatic async fromMemoryPointer(\n\t\tmp: MemoryPointer,\n\t\tresolver: RangeResolver,\n\t\tdataFilePointer: RangeResolver,\n\t\tfileFormat: FileFormat,\n\t\tpageFieldType: FieldType\n\t): Promise<{ node: BPTreeNode; bytesRead: number }> {\n\t\tconst { data: bufferData } = await resolver({\n\t\t\tstart: Number(mp.offset),\n\t\t\tend: Number(mp.offset) + 4096 - 1,\n\t\t});\n\t\tconst node = new BPTreeNode(\n\t\t\t[],\n\t\t\t[],\n\t\t\t[],\n\t\t\tdataFilePointer,\n\t\t\tfileFormat,\n\t\t\tpageFieldType\n\t\t);\n\n\t\tawait node.unmarshalBinary(bufferData);\n\n\t\treturn { node, bytesRead: pageSizeBytes };\n\t}\n}\n", "import { BPTree, ReferencedValue } from \"./bptree\";\nimport { BPTreeNode, MemoryPointer } from \"./node\";\n\nexport type TraversalRecord = {\n\tnode: BPTreeNode;\n\tindex: number;\n\tpointer: MemoryPointer;\n};\n\nexport class TraversalIterator {\n\tprivate tree: BPTree;\n\tprivate key: ReferencedValue;\n\tprivate records: TraversalRecord[];\n\n\tconstructor(tree: BPTree, key: ReferencedValue) {\n\t\tthis.tree = tree;\n\t\tthis.key = key;\n\t\tthis.records = []; // note this works iff all records are non-empty\n\t}\n\n\tasync init(): Promise<boolean> {\n\t\tconst rootResponse = await this.tree.root();\n\n\t\tif (rootResponse.rootNode === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst root = rootResponse.rootNode;\n\t\tconst offset = rootResponse.pointer;\n\t\tconst path = await this.tree.traverse(this.key, root, offset);\n\t\tthis.records = path;\n\t\treturn true;\n\t}\n\n\tgetKey(): ReferencedValue {\n\t\treturn this.records[0].node.keys[this.records[0].index];\n\t}\n\n\tgetPointer(): MemoryPointer {\n\t\treturn this.records[0].node.pointer(this.records[0].index);\n\t}\n\n\tasync increment(i: number, delta: number): Promise<boolean> {\n\t\tif (i === this.records.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.records[i].index += delta;\n\t\tconst rolloverLeft = this.records[i].index < 0;\n\t\tconst rolloverRight =\n\t\t\tthis.records[i].index >= this.records[i].node.numPointers();\n\n\t\tif (rolloverLeft || rolloverRight) {\n\t\t\tif (!this.increment(i + 1, delta)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.records[i + 1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst node = await this.tree.readNode(\n\t\t\t\tthis.records[i + 1].node.pointer(this.records[i + 1].index)\n\t\t\t);\n\n\t\t\t// propagate the rollover\n\t\t\tthis.records[i].node = node;\n\n\t\t\tif (rolloverLeft) {\n\t\t\t\tthis.records[i].index = this.records[i].node.numPointers() - 1;\n\t\t\t} else {\n\t\t\t\tthis.records[i].index = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync next(): Promise<boolean> {\n\t\tif (this.records.length === 0) {\n\t\t\treturn await this.init();\n\t\t}\n\n\t\treturn this.increment(0, 1);\n\t}\n\n\tasync prev(): Promise<boolean> {\n\t\tif (this.records.length === 0) {\n\t\t\tconst res = await this.init();\n\t\t\tif (!res) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn this.increment(0, -1);\n\t}\n}\n", "import { RangeResolver } from \"../resolver\";\nimport { MemoryPointer } from \"./node\";\nimport { PageFile } from \"./pagefile\";\n\nconst PAGE_SIZE_BYTES = 4096;\nexport const maxUint64 = 2n ** 64n - 1n;\n\nexport class LinkedMetaPage {\n\tprivate resolver: RangeResolver;\n\tprivate offset: bigint;\n\tprivate metaPageData: ArrayBuffer | null;\n\tprivate metaPagePromise: Promise<ArrayBuffer> | null = null;\n\n\tconstructor(resolver: RangeResolver, offset: bigint) {\n\t\tthis.resolver = resolver;\n\t\tthis.offset = offset;\n\t\tthis.metaPageData = null;\n\t}\n\n\tasync root(): Promise<MemoryPointer> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\t// we seek by 12 bytes since offset is 8 bytes, length is 4 bytes\n\t\tconst data = pageData.slice(0, 12);\n\t\tconst view = new DataView(data);\n\n\t\tconst pointerOffset = view.getBigUint64(0);\n\t\tconst lengthOffset = view.getUint32(8);\n\n\t\treturn {\n\t\t\toffset: pointerOffset,\n\t\t\tlength: lengthOffset,\n\t\t};\n\t}\n\n\t/**\n\t * `metadata()` gets the page data. It does the following:\n\t * \t\t(1) creates a slice from 24 to the end of the page\n\t * \t\t(2) it reads the first four bytes of that slice which gives us the length to seek to\n\t * \t\t(3) slices from [24, (24 + dataLength)] which contain metadata\n\t */\n\tasync metadata(): Promise<ArrayBuffer> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\tconst lengthView = new DataView(pageData, 24);\n\n\t\t// read the first four because that represents length\n\t\tconst metadataLength = lengthView.getUint32(0);\n\n\t\treturn pageData.slice(28, 28 + metadataLength);\n\t}\n\n\t/**\n\t * `getMetaPage()` seeks the index-file with the absolute bounds for a given page file.\n\t * It caches the data in a pagefile. Note: all other methods that call this should be slicing with relative bounds.\n\t */\n\tprivate async getMetaPage(): Promise<ArrayBuffer> {\n\t\tif (this.metaPageData) {\n\t\t\treturn this.metaPageData;\n\t\t}\n\n\t\tif (!this.metaPagePromise) {\n\t\t\tthis.metaPagePromise = this.resolver({\n\t\t\t\tstart: Number(this.offset),\n\t\t\t\tend: Number(this.offset) + PAGE_SIZE_BYTES - 1,\n\t\t\t})\n\t\t\t\t.then(({ data }) => {\n\t\t\t\t\tthis.metaPageData = data;\n\t\t\t\t\tthis.metaPagePromise = null;\n\t\t\t\t\treturn data;\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tthis.metaPagePromise = null;\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this.metaPagePromise;\n\t}\n\n\t/**\n\t * `next()` - returns a new LinkedMetaPage\n\t */\n\tasync next(): Promise<LinkedMetaPage | null> {\n\t\tconst pageData = await this.getMetaPage();\n\n\t\tconst view = new DataView(pageData, 12, 8);\n\t\tconst nextOffset = view.getBigUint64(0);\n\n\t\tif (nextOffset === maxUint64) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new LinkedMetaPage(this.resolver, nextOffset);\n\t}\n\n\tgetOffset(): bigint {\n\t\treturn this.offset;\n\t}\n}\n\nexport function ReadMultiBPTree(\n\tresolver: RangeResolver,\n\tpageFile: PageFile\n): LinkedMetaPage {\n\tconst offset = pageFile.page(0);\n\treturn new LinkedMetaPage(resolver, offset);\n}\n", "import { BPTreeNode, MemoryPointer } from \"./node\";\nimport { RangeResolver } from \"../resolver\";\nimport { TraversalIterator, TraversalRecord } from \"./traversal\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { FieldType } from \"../db/database\";\nimport { maxUint64 } from \"./multi\";\n\nexport interface MetaPage {\n  root(): Promise<MemoryPointer>;\n}\n\ntype RootResponse = {\n  rootNode: BPTreeNode | null;\n  pointer: MemoryPointer;\n};\n\nexport class BPTree {\n  private readonly tree: RangeResolver;\n  private meta: MetaPage;\n  private readonly dataFileResolver: RangeResolver;\n  private fileFormat: FileFormat;\n  private pageFieldType: FieldType;\n\n  private firstRef: ReferencedValue = new ReferencedValue({ offset: 0n, length: 0 }, new Uint8Array([0x00]).buffer)\n  private lastRef: ReferencedValue = new ReferencedValue({ offset: maxUint64, length: 0 }, new Uint8Array([0xFF]).buffer)\n\n  constructor(\n    tree: RangeResolver,\n    meta: MetaPage,\n    dataFileResolver: RangeResolver,\n    fileFormat: FileFormat,\n    pageFieldType: FieldType\n  ) {\n    this.tree = tree;\n    this.meta = meta;\n    this.dataFileResolver = dataFileResolver;\n    this.fileFormat = fileFormat;\n    this.pageFieldType = pageFieldType;\n  }\n\n  async root(): Promise<RootResponse> {\n    const mp = await this.meta.root();\n\n    if (!mp || mp.length === 0) {\n      return {\n        rootNode: null,\n        pointer: mp,\n      };\n    }\n\n    const root = await this.readNode(mp);\n    if (!root) {\n      return {\n        rootNode: null,\n        pointer: mp,\n      };\n    }\n\n    return {\n      rootNode: root,\n      pointer: mp,\n    };\n  }\n\n  async readNode(ptr: MemoryPointer): Promise<BPTreeNode> {\n    try {\n      const { node, bytesRead } = await BPTreeNode.fromMemoryPointer(\n        ptr,\n        this.tree,\n        this.dataFileResolver,\n        this.fileFormat,\n        this.pageFieldType\n      );\n\n      if (!bytesRead) {\n        throw new Error(\"bytes read do not line up\");\n      }\n\n      return node;\n    } catch (error) {\n      throw new Error(`${error}`);\n    }\n  }\n\n  public iter(key: ReferencedValue): TraversalIterator {\n    return new TraversalIterator(this, key);\n  }\n\n  async first(\n  ): Promise<ReferencedValue> {\n    let { rootNode } = await this.root();\n    if (!rootNode) {\n      throw new Error(\"unable to get root node\")\n    }\n\n    let currNode = await this.readNode(rootNode.pointer(0))\n\n    while (!currNode.leaf()) {\n      const childPointer = currNode.pointer(0);\n      currNode = await this.readNode(childPointer);\n    }\n\n    return currNode.keys[0]\n  }\n\n  async last(): Promise<ReferencedValue> {\n    let { rootNode } = await this.root();\n    if (!rootNode) {\n      throw new Error(\"unable to get root node\")\n    }\n\n    let currNode = await this.readNode(rootNode.pointer(rootNode.numPointers() - 1))\n\n    while (!currNode.leaf()) {\n      const childPointer = currNode.pointer(currNode.numPointers() - 1);\n      currNode = await this.readNode(childPointer);\n    }\n\n    return currNode.keys[currNode.keys.length - 1]\n  }\n\n  async traverse(\n    key: ReferencedValue,\n    node: BPTreeNode,\n    pointer: MemoryPointer\n  ): Promise<TraversalRecord[]> {\n    let [index, found] = binarySearchReferencedValues(node.keys, key);\n    if (node.leaf()) {\n      return [{ node, index, pointer }];\n    }\n\n    if (found) {\n      index += 1;\n    }\n\n    const childPointer = node.pointer(index);\n    const child = await this.readNode(childPointer);\n    const path = await this.traverse(key, child, childPointer);\n\n    return [...path, { node, index, pointer }];\n  }\n\n  public async find(\n    key: ReferencedValue\n  ): Promise<[ReferencedValue, MemoryPointer]> {\n    const p = this.iter(key);\n\n    if (!(await p.next())) {\n      return [\n        new ReferencedValue(\n          { offset: 0n, length: 0 },\n          new Uint8Array(0).buffer\n        ),\n        { offset: 0n, length: 0 },\n      ];\n    }\n\n    return [p.getKey(), p.getPointer()];\n  }\n}\n\nexport class ReferencedValue {\n  public dataPointer: MemoryPointer;\n  public value: ArrayBuffer;\n\n  constructor(dataPointer: MemoryPointer, value: ArrayBuffer) {\n    this.dataPointer = dataPointer;\n    this.value = value;\n  }\n\n  setDataPointer(mp: MemoryPointer) {\n    this.dataPointer = mp;\n  }\n\n  setValue(value: ArrayBuffer) {\n    this.value = value;\n  }\n\n  static compareBytes(aBuffer: ArrayBuffer, bBuffer: ArrayBuffer): number {\n    const a = new Uint8Array(aBuffer);\n    const b = new Uint8Array(bBuffer);\n\n    const len = Math.min(a.length, b.length);\n    for (let idx = 0; idx < len; idx++) {\n      if (a[idx] !== b[idx]) {\n        return a[idx] < b[idx] ? -1 : 1;\n      }\n    }\n\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  }\n}\n\nfunction compareReferencedValues(\n  a: ReferencedValue,\n  b: ReferencedValue\n): number {\n  const valueComparison = ReferencedValue.compareBytes(a.value, b.value);\n  if (valueComparison !== 0) {\n    return valueComparison;\n  }\n\n  if (a.dataPointer.offset > b.dataPointer.offset) {\n    return 1;\n  } else if (a.dataPointer.offset < b.dataPointer.offset) {\n    return -1;\n  }\n\n  if (a.dataPointer.length > b.dataPointer.length) {\n    return 1;\n  } else if (a.dataPointer.length < b.dataPointer.length) {\n    return -1;\n  }\n\n  return 0;\n}\n\nexport function binarySearchReferencedValues(\n  values: ReferencedValue[],\n  target: ReferencedValue\n): [number, boolean] {\n  const n = values.length;\n\n  let i = 0;\n  let j = n;\n\n  while (i < j) {\n    const h = Math.floor((i + j) / 2);\n\n    if (compareReferencedValues(values[h], target) < 0) {\n      i = h + 1;\n    } else {\n      j = h;\n    }\n  }\n\n  return [i, i < n && compareReferencedValues(values[i], target) === 0];\n}\n", "import { Database, OrderBy, Query, Schema, WhereNode } from \"./database\";\n\n/**\n * A class for building and executing database queries in a flexible API style.\n * Allows chaining methods for 'where', 'orderBy', 'select', and 'limit' clauses.\n */\nexport class QueryBuilder<T extends Schema> {\n\tprivate queryObject: Query<T> = {\n\t\twhere: [],\n\t\torderBy: undefined,\n\t\tselect: undefined,\n\t\tlimit: undefined,\n\t};\n\n\t/**\n\t * Initializes a new instance of the QueryBuilder class.\n\t * @param {Database<T>} database - An Appendable database instance to execute queries against.\n\t */\n\tconstructor(private database: Database<T>) {}\n\n\t/**\n\t * Retrieves an immutable copy of the current query.\n\t *\n\t * @returns {Query<T>} The Query instance.\n\t */\n\ttoQuery(): Query<T> {\n\t\treturn {\n\t\t\twhere: this.queryObject.where ? [...this.queryObject.where] : [],\n\t\t\torderBy: this.queryObject.orderBy\n\t\t\t\t? [...this.queryObject.orderBy]\n\t\t\t\t: undefined,\n\t\t\tselect: this.queryObject.select\n\t\t\t\t? [...this.queryObject.select]\n\t\t\t\t: undefined,\n\t\t\tlimit: this.queryObject.limit,\n\t\t};\n\t}\n\n\t/**\n\t * Executes the constructed query\n\t */\n\tget() {\n\t\t//return this.database.query(this.queryObject);\n\t}\n\n\t/**\n\t * Adds a 'where' clause to the query.\n\t *\n\t * @param {keyof T} key - The index header's field name to apply the 'where' condition.\n\t * @param {WhereNode<T>[\"operation\"]} operation - The comparison relation (e.g., >=, <=, ==, >=, >).\n\t * @param {T[keyof T]} value - The value to compare against.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\twhere(\n\t\tkey: keyof T,\n\t\toperation: WhereNode<T>[\"operation\"],\n\t\tvalue: T[keyof T]\n\t): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\twhere: [...(this.queryObject.where || []), { key, operation, value }],\n\t\t};\n\t\treturn newQuery;\n\t}\n\t/**\n\t * Adds an 'orderBy' clause to the query.\n\t *\n\t * @param {keyof T} key - The index header's field name to order by.\n\t * @param {OrderBy<T>[\"direction\"]} direction - The sorting direction (e.g., ASC, DESC).\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\torderBy(key: keyof T, direction: OrderBy<T>[\"direction\"]): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\torderBy: [...(this.queryObject.orderBy || []), { key, direction }],\n\t\t};\n\t\treturn newQuery;\n\t}\n\n\t/**\n\t * Specifies the fields to be selected in the query.\n\t *\n\t * @param {(keyof T)[]} keys - A list of index header field names.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\tselect(keys: (keyof T)[]): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\tselect: keys,\n\t\t};\n\t\treturn newQuery;\n\t}\n\n\t/**\n\t * Limits the number of records returned by the query.\n\t *\n\t * @param {number} limit - The maximum number of records to return.\n\t * @returns {QueryBuilder<T>} The QueryBuilder instance.\n\t */\n\tlimit(limit: number): QueryBuilder<T> {\n\t\tconst newQuery = new QueryBuilder<T>(this.database);\n\t\tnewQuery.queryObject = {\n\t\t\t...this.queryObject,\n\t\t\tlimit: limit,\n\t\t};\n\t\treturn newQuery;\n\t}\n}\n", "import { FieldType, OrderBy, Schema } from \"./database\";\n\n\ntype QueryWhere = {\n  valueBuf: ArrayBuffer,\n  fieldType: FieldType\n}\n\nexport function processWhere<T>(value: T[keyof T]): QueryWhere | null {\n  let valueBuf: ArrayBuffer;\n\n  if (value === null) {\n    return {\n      fieldType: FieldType.Null,\n      valueBuf: new ArrayBuffer(0)\n    }\n  } else {\n    switch (typeof value) {\n      case \"bigint\":\n      case \"number\":\n        valueBuf = new ArrayBuffer(8);\n        new DataView(valueBuf).setFloat64(0, Number(value), true)\n        return {\n          fieldType: FieldType.Float64,\n          valueBuf\n        }\n      case \"boolean\":\n        return {\n          fieldType: FieldType.Boolean,\n          valueBuf: new Uint8Array([value ? 1 : 0]).buffer\n        }\n\n      case \"string\":\n        return {\n          fieldType: FieldType.String,\n          valueBuf: new TextEncoder().encode(value as string).buffer\n        }\n    }\n  }\n\n  return null\n}\n\n\n\nexport function handleSelect<T>(data: string, select?: (keyof T)[]) {\n  let jData = JSON.parse(data)\n  if (select && select.length > 0) {\n    return select.reduce(\n      (acc, field) => {\n        if (field in jData) {\n          acc[field] = jData[field];\n        }\n        return acc;\n      },\n      {} as Pick<T, keyof T>\n    );\n  }\n\n  return jData\n}\n", "import { BPTree, ReferencedValue } from \"../btree/bptree\";\nimport { maxUint64 } from \"../btree/multi\";\nimport { DataFile } from \"../data-file\";\nimport { VersionedIndexFile } from \"../index-file/index-file\";\nimport { readIndexMeta } from \"../index-file/meta\";\nimport { QueryBuilder } from \"./query-builder\";\nimport { handleSelect, processWhere } from \"./query-logic\";\n\nexport type Schema = {\n  [key: string]: {};\n};\n\nexport type WhereNode<T extends Schema, K extends keyof T = keyof T> = {\n  operation: \"<\" | \"<=\" | \"==\" | \">=\" | \">\";\n  key: keyof T;\n  value: T[K];\n};\n\nexport type OrderBy<T extends Schema> = {\n  key: keyof T;\n  direction: \"ASC\" | \"DESC\";\n};\n\nexport type SelectField<T extends Schema> = keyof T;\n\nexport type Query<T extends Schema> = {\n  where?: WhereNode<T>[];\n  orderBy?: OrderBy<T>[];\n  select?: SelectField<T>[];\n  limit?: number;\n};\n\nexport enum FieldType {\n  String = 0,\n  Int64 = 1,\n  Uint64 = 2,\n  Float64 = 3,\n  Object = 4,\n  Array = 5,\n  Boolean = 6,\n  Null = 7,\n}\n\nexport class Database<T extends Schema> {\n  private constructor(\n    private dataFile: DataFile,\n    private indexFile: VersionedIndexFile<T>\n  ) { }\n\n  static forDataFileAndIndexFile<T extends Schema>(\n    dataFile: DataFile,\n    indexFile: VersionedIndexFile<T>\n  ) {\n    return new Database(dataFile, indexFile);\n  }\n\n  async fields() {\n    return await this.indexFile.indexHeaders();\n  }\n\n  async *query(query: Query<T>) {\n    if (new Set((query.where ?? []).map((where) => where.key)).size > 1) {\n      throw new Error(\"composite indexes not supported... yet\");\n    }\n\n    const { format } = await this.indexFile.metadata();\n    const dfResolver = this.dataFile.getResolver();\n\n    if (dfResolver === undefined) {\n      throw new Error(\"data file is undefined\");\n    }\n\n    const headers = await this.indexFile.indexHeaders();\n\n    for (const { key, value, operation } of query.where ?? []) {\n      const header = headers.find((header) => header.fieldName === key);\n      if (!header) {\n        throw new Error(\"field not found\");\n      }\n\n      const res = processWhere(value);\n      if (res === null) {\n        throw new Error(`unable to process key with a type ${typeof value}`)\n      }\n      const { fieldType, valueBuf } = res;\n\n      const mps = await this.indexFile.seek(key as string, fieldType);\n      const mp = mps[0];\n      const { fieldType: mpFieldType } = await readIndexMeta(\n        await mp.metadata()\n      );\n\n\n      let ord: \"ASC\" | \"DESC\" = \"ASC\";\n      if (query.orderBy && query.orderBy[0]) {\n        ord = query.orderBy[0].direction\n      }\n\n      const bptree = new BPTree(\n        this.indexFile.getResolver(),\n        mp,\n        dfResolver,\n        format,\n        mpFieldType\n      );\n\n      if (operation === \">\") {\n        if (ord === \"ASC\") {\n          const valueRef = new ReferencedValue({ offset: 0n, length: 0 }, valueBuf)\n          const iter = bptree.iter(valueRef);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === -1) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const lastKey = await bptree.last();\n          const iter = bptree.iter(lastKey);\n\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === -1) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n              yield handleSelect(data, query.select);\n            } else {\n              console.log(\"less than\")\n            }\n          }\n        }\n      } else if (operation === \">=\") {\n        if (ord === \"ASC\") {\n          const valueRef = new ReferencedValue({ offset: 0n, length: 0 }, valueBuf)\n          const iter = bptree.iter(valueRef);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === -1 || res === 0) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const lastKey = await bptree.last();\n          const iter = bptree.iter(lastKey);\n\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === -1 || res === 0) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      } else if (operation === \"==\") {\n        const valueRef = new ReferencedValue({ offset: 0n, length: 0 }, valueBuf)\n        const iter = bptree.iter(valueRef);\n\n        while (await iter.next()) {\n          const currentKey = iter.getKey();\n\n          let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n          if (res === 0) {\n            const [_, mp] = await bptree.find(currentKey);\n\n            const data = await this.dataFile.get(\n              Number(mp.offset),\n              Number(mp.offset) + mp.length - 1\n            );\n\n            yield handleSelect(data, query.select);\n          }\n        }\n      } else if (operation === \"<=\") {\n        if (ord === \"DESC\") {\n          const valueRef = new ReferencedValue({ offset: maxUint64, length: 0 }, valueBuf)\n          const iter = bptree.iter(valueRef);\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === 1 || res === 0) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const firstKey = await bptree.first();\n          const iter = bptree.iter(firstKey);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === 1 || 0) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      } else if (operation === \"<\") {\n        if (ord === \"DESC\") {\n          const valueRef = new ReferencedValue({ offset: maxUint64, length: 0 }, valueBuf)\n          const iter = bptree.iter(valueRef);\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === 1) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const firstKey = await bptree.first();\n          const iter = bptree.iter(firstKey);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            let res = ReferencedValue.compareBytes(valueBuf, currentKey.value);\n            if (res === 1) {\n              const [_, mp] = await bptree.find(currentKey);\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n  where(\n    key: keyof T,\n    operation: WhereNode<T>[\"operation\"],\n    value: T[keyof T]\n  ): QueryBuilder<T> {\n    return new QueryBuilder(this).where(key, operation, value);\n  }\n}\n", "/**\n * RangeResolver is a function that takes a range of bytes and returns a promise\n * that resolves to an ArrayBuffer containing the bytes in that range. Note that\n * the range is inclusive.\n *\n * Additionally, the RangeResolver must return a checksum which is computed from\n * the source data. This checksum is used to verify that the data has not been\n * changed between requests. The checksum can be any type, for example it is\n * valid to use the last modified timestamp of the source data or the total\n * length of the data. This checksum is passed to the RangeResolver on future\n * requests as the `checksum` argument. If it does not match the checksum when\n * reading the data, the RangeResolver should throw a LengthIntegrityError.\n *\n * @see LengthIntegrityError\n */\nexport type RangeResolver = (args: {\n\tstart: number;\n\tend: number;\n\texpectedLength?: number;\n}) => Promise<{\n\tdata: ArrayBuffer;\n\ttotalLength: number;\n}>;\n\n/**\n * LengthIntegrityError is thrown by a RangeResolver when the length argument is\n * inconsistent with the data returned. This is used to detect when the data has\n * changed between requests.\n *\n * When a LengthIntegrityError is thrown, typically the cache is evicted and the\n * query will be tried again with the exception of the data file where the error\n * is ignored due to the assumed immutability of the data file.\n *\n * @see RangeResolver\n */\nexport class LengthIntegrityError extends Error {\n\tconstructor() {\n\t\tsuper(\"length integrity error\");\n\t}\n}\n", "import {RangeResolver} from \"../resolver\";\n\nconst pageSizeBytes = 4096;\n\nexport class PageFile {\n\n    private resolver: RangeResolver;\n    private pageSize: number = pageSizeBytes;\n\n    constructor(resolver: RangeResolver) {\n        this.resolver = resolver;\n    }\n\n    async readPage(idx: number): Promise<ArrayBuffer> {\n        if(idx < 0) {\n            throw new Error(\"page cannot be indexed\");\n        }\n\n        const start = (idx + 1) * this.pageSize;\n        const end = start + this.pageSize - 1;\n\n        const { data } = await this.resolver({ start, end: end - 1 });\n\n        return data;\n    }\n\n    page(idx: number): bigint {\n        if (idx < 0) {\n            return BigInt(0);\n        }\n\n        return BigInt(idx + 1) * BigInt(this.pageSize);\n    }\n}\n", "import { LinkedMetaPage, ReadMultiBPTree } from \"../btree/multi\";\nimport { LengthIntegrityError, RangeResolver } from \"../resolver\";\nimport { PageFile } from \"../btree/pagefile\";\nimport {\n\tFileFormat,\n\tIndexHeader,\n\tIndexMeta,\n\tcollectIndexMetas,\n\treadIndexMeta,\n} from \"./meta\";\nimport { FieldType } from \"../db/database\";\n\nexport class IndexFile {\n\tstatic async forUrl<T = any>(url: string) {\n\t\treturn await IndexFile.forResolver<T>(\n\t\t\tasync ({ start, end, expectedLength }) => {\n\t\t\t\tconst response = await fetch(url, {\n\t\t\t\t\theaders: { Range: `bytes=${start}-${end}` },\n\t\t\t\t});\n\t\t\t\tconst totalLength = Number(\n\t\t\t\t\tresponse.headers.get(\"Content-Range\")!.split(\"/\")[1]\n\t\t\t\t);\n\t\t\t\tif (expectedLength && totalLength !== expectedLength) {\n\t\t\t\t\tthrow new LengthIntegrityError();\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdata: await response.arrayBuffer(),\n\t\t\t\t\ttotalLength: totalLength,\n\t\t\t\t};\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic async forResolver<T = any>(\n\t\tresolver: RangeResolver\n\t): Promise<VersionedIndexFile<T>> {\n\t\treturn new IndexFileV1<T>(resolver);\n\t}\n}\n\nfunction decodeFloatingInt16(x: number) {\n\tconst exponent = x >> 11;\n\tconst mantissa = x & 0x7ff;\n\treturn (1 << exponent) * mantissa + (1 << (exponent + 11)) - (1 << 11);\n}\n\nexport type FileMeta = {\n\tversion: number;\n\tformat: number;\n\treadOffset: bigint;\n};\n\nexport interface VersionedIndexFile<T> {\n\tgetResolver(): RangeResolver;\n\n\ttree(): Promise<LinkedMetaPage>;\n\n\tmetadata(): Promise<FileMeta>;\n\n\tindexHeaders(): Promise<IndexHeader[]>;\n\n\tseek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]>;\n}\n\nexport class IndexFileV1<T> implements VersionedIndexFile<T> {\n\tprivate _tree?: LinkedMetaPage;\n\n\tconstructor(private resolver: RangeResolver) {}\n\n\tgetResolver(): RangeResolver {\n\t\treturn this.resolver;\n\t}\n\n\tasync tree(): Promise<LinkedMetaPage> {\n\t\tif (this._tree) {\n\t\t\treturn this._tree;\n\t\t}\n\n\t\tconst pageFile = new PageFile(this.resolver);\n\t\tconst tree = ReadMultiBPTree(this.resolver, pageFile);\n\n\t\tthis._tree = tree;\n\t\treturn tree;\n\t}\n\n\tasync metadata(): Promise<FileMeta> {\n\t\tconst tree = await this.tree();\n\n\t\tconst buffer = await tree.metadata();\n\n\t\t// unmarshall binary for FileMeta\n\t\tif (buffer.byteLength < 10) {\n\t\t\tthrow new Error(\n\t\t\t\t`incorrect byte length! Want: 10, got ${buffer.byteLength}`\n\t\t\t);\n\t\t}\n\n\t\tconst dataView = new DataView(buffer);\n\t\tconst version = dataView.getUint8(0);\n\t\tconst formatByte = dataView.getUint8(1);\n\n\t\tif (Object.values(FileFormat).indexOf(formatByte) === -1) {\n\t\t\tthrow new Error(`unexpected file format. Got: ${formatByte}`);\n\t\t}\n\n\t\tconst readOffset = dataView.getBigUint64(2);\n\n\t\treturn {\n\t\t\tversion: version,\n\t\t\tformat: formatByte,\n\t\t\treadOffset: readOffset,\n\t\t};\n\t}\n\n\tasync seek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]> {\n\t\tlet mp = await this.tree();\n\n\t\tlet headerMps = [];\n\n\t\twhile (mp) {\n\t\t\tconst next = await mp.next();\n\t\t\tif (next === null) {\n\t\t\t\treturn headerMps;\n\t\t\t}\n\n\t\t\tconst indexMeta = await readIndexMeta(await next.metadata());\n\t\t\tif (indexMeta.fieldName === header) {\n\t\t\t\tif (fieldType === FieldType.Float64) {\n\t\t\t\t\t// if key is a number or bigint, we cast it as a float64 type\n\t\t\t\t\tif (\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Float64 ||\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Int64 ||\n\t\t\t\t\t\tindexMeta.fieldType === FieldType.Uint64\n\t\t\t\t\t) {\n\t\t\t\t\t\theaderMps.push(next);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (indexMeta.fieldType === fieldType) {\n\t\t\t\t\t\theaderMps.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmp = next;\n\t\t}\n\n\t\tif (headerMps.length === 0) {\n\t\t\tthrow new Error(\n\t\t\t\t`No LinkedMetaPage with ${header} and type ${fieldType} exists`\n\t\t\t);\n\t\t}\n\n\t\treturn headerMps;\n\t}\n\n\tasync indexHeaders(): Promise<IndexHeader[]> {\n\t\tlet headers: IndexMeta[] = [];\n\n\t\tlet mp = await this.tree();\n\n\t\twhile (mp) {\n\t\t\tconst next = await mp.next();\n\t\t\tif (next === null) {\n\t\t\t\treturn collectIndexMetas(headers);\n\t\t\t}\n\n\t\t\tconst nextBuffer = await next.metadata();\n\t\t\tconst indexMeta = await readIndexMeta(nextBuffer);\n\n\t\t\theaders.push(indexMeta);\n\n\t\t\tmp = next;\n\t\t}\n\n\t\treturn collectIndexMetas(headers);\n\t}\n}\n", "import { DataFile } from \"./data-file\";\nimport { Database, FieldType } from \"./db/database\";\nimport { IndexFile } from \"./index-file/index-file\";\nimport { RangeResolver } from \"./resolver\";\n\nexport async function init(\n\tdataUrl: string | RangeResolver,\n\tindexUrl: string | RangeResolver\n) {\n\treturn Database.forDataFileAndIndexFile(\n\t\ttypeof dataUrl === \"string\"\n\t\t\t? DataFile.forUrl(dataUrl)\n\t\t\t: DataFile.forResolver(dataUrl),\n\t\ttypeof indexUrl === \"string\"\n\t\t\t? await IndexFile.forUrl(indexUrl)\n\t\t\t: await IndexFile.forResolver(indexUrl)\n\t);\n}\n\ninterface GlobalMap {\n\tAppendable: {\n\t\tinit: Function;\n\t\tFieldType: typeof FieldType;\n\t};\n}\n\ndeclare global {\n\tvar Appendable: GlobalMap[\"Appendable\"];\n}\n\nglobalThis.Appendable = {\n\tinit,\n\tFieldType,\n};\n"],
  "mappings": "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",
  "names": ["DataFile", "_DataFile", "resolver", "url", "start", "end", "response", "totalLength", "instance", "expectedLength", "startByteOffset", "endByteOffset", "data", "FileFormat", "readIndexMeta", "buffer", "dataView", "fieldType", "nameLength", "fieldNameBuffer", "collectIndexMetas", "indexMetas", "headersMap", "meta", "updatedTypes", "indexHeaders", "fieldTypes", "fieldName", "pageSizeBytes", "BPTreeNode", "_BPTreeNode", "keys", "leafPointers", "internalPointers", "dataFileResolver", "fileFormat", "pageFieldType", "i", "size", "idx", "k", "buffer", "dataView", "ReferencedValue", "m", "l", "dpOffset", "dpLength", "dp", "data", "parsedData", "value", "incomingData", "stringData", "jValue", "floatBuf", "mp", "resolver", "dataFilePointer", "bufferData", "node", "TraversalIterator", "tree", "key", "rootResponse", "root", "offset", "path", "i", "delta", "rolloverLeft", "rolloverRight", "node", "PAGE_SIZE_BYTES", "maxUint64", "LinkedMetaPage", "_LinkedMetaPage", "resolver", "offset", "data", "view", "pointerOffset", "lengthOffset", "pageData", "metadataLength", "error", "nextOffset", "ReadMultiBPTree", "pageFile", "BPTree", "tree", "meta", "dataFileResolver", "fileFormat", "pageFieldType", "ReferencedValue", "maxUint64", "mp", "root", "ptr", "node", "bytesRead", "BPTreeNode", "error", "key", "TraversalIterator", "rootNode", "currNode", "childPointer", "pointer", "index", "found", "binarySearchReferencedValues", "child", "p", "dataPointer", "value", "aBuffer", "bBuffer", "a", "b", "len", "idx", "compareReferencedValues", "valueComparison", "values", "target", "n", "i", "j", "h", "QueryBuilder", "_QueryBuilder", "database", "key", "operation", "value", "newQuery", "direction", "keys", "limit", "processWhere", "value", "valueBuf", "handleSelect", "data", "select", "jData", "acc", "field", "FieldType", "Database", "_Database", "dataFile", "indexFile", "query", "where", "format", "dfResolver", "headers", "key", "value", "operation", "header", "res", "processWhere", "fieldType", "valueBuf", "mp", "mpFieldType", "readIndexMeta", "ord", "bptree", "BPTree", "valueRef", "ReferencedValue", "iter", "currentKey", "_", "data", "handleSelect", "lastKey", "maxUint64", "firstKey", "QueryBuilder", "LengthIntegrityError", "pageSizeBytes", "PageFile", "resolver", "idx", "start", "end", "data", "IndexFile", "_IndexFile", "url", "start", "end", "expectedLength", "response", "totalLength", "LengthIntegrityError", "resolver", "IndexFileV1", "IndexFileV1", "resolver", "pageFile", "PageFile", "tree", "ReadMultiBPTree", "buffer", "dataView", "version", "formatByte", "FileFormat", "readOffset", "header", "fieldType", "mp", "headerMps", "next", "indexMeta", "readIndexMeta", "headers", "collectIndexMetas", "nextBuffer", "init", "dataUrl", "indexUrl", "Database", "DataFile", "IndexFile", "FieldType"]
}
