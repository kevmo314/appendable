{
  "version": 3,
  "sources": ["../src/multipart.ts", "../src/resolver.ts", "../src/range-request.ts", "../src/data-file.ts", "../src/index-file/meta.ts", "../src/btree/node.ts", "../src/btree/traversal.ts", "../src/btree/bptree.ts", "../src/btree/multi.ts", "../src/db/query-builder.ts", "../src/db/query-logic.ts", "../src/db/query-validation.ts", "../src/db/database.ts", "../src/index-file/index-file.ts", "../src/index.ts"],
  "sourcesContent": ["function getReader(stream: ReadableStream) {\n  let residual: Uint8Array | null = null;\n  let readDone = false;\n  let reader: ReadableStreamDefaultReader<Uint8Array> = stream.getReader();\n  return async (\n    buf: Uint8Array,\n  ): Promise<ReadableStreamReadResult<Uint8Array>> => {\n    if (reader instanceof ReadableStreamBYOBReader) {\n      return await reader.read(buf);\n    } else {\n      while (true) {\n        if (residual) {\n          const n = Math.min(residual.length, buf.length);\n          buf.set(residual.subarray(0, n));\n          residual = residual.subarray(n);\n          if (residual.length === 0) {\n            residual = null;\n          }\n          return {\n            done: readDone && residual === null,\n            value: buf.subarray(0, n),\n          };\n        }\n        const result = await reader.read();\n        if (result.value) {\n          residual = result.value;\n        }\n        readDone ||= result.done;\n      }\n    }\n  };\n}\n\nfunction parseContentRangeHeader(\n  header: string,\n): [string, number, number, number] {\n  // parse bytes a-b/c\n  const tokens = header.split(\" \");\n  if (tokens.length !== 2) {\n    throw new Error(\"Invalid Content-Range header\");\n  }\n  const [range, total] = tokens[1].split(\"/\");\n  const [start, end] = range.split(\"-\");\n  return [tokens[0], Number(start), Number(end), Number(total)];\n}\n\nexport default async function* parseMultipartBody(\n  contentType: string,\n  stream: ReadableStream,\n): AsyncGenerator<{ data: ArrayBuffer; headers: Record<string, string> }> {\n  const reader = getReader(stream);\n  const tokens = contentType.split(\";\");\n  if (tokens[0] !== \"multipart/byteranges\") {\n    throw new Error(\"Not a multipart/byteranges body\");\n  }\n  const boundaryToken = tokens\n    .map((s) => s.trim())\n    .find((s) => s.startsWith(\"boundary=\"))\n    ?.split(\"=\", 2)?.[1];\n  if (!boundaryToken) {\n    throw new Error(\"No boundary found\");\n  }\n  const boundary = `--${boundaryToken}`;\n\n  let headers: Record<string, string> = {};\n\n  const buf = new Uint8Array(4096);\n  let ptr = 0;\n  let length = 0;\n\n  const extend = async () => {\n    if (length === buf.byteLength) {\n      throw new Error(\"no buffer space left\");\n    }\n    const { done, value } = await reader(\n      ptr + length >= buf.length\n        ? buf.subarray((ptr + length) % buf.length, ptr)\n        : buf.subarray(ptr + length, buf.length),\n    );\n    if (done) {\n      return done;\n    }\n    length += value.length;\n    return false;\n  };\n\n  while (true) {\n    // read boundary\n    for (let i = 0; i < boundary.length; i++) {\n      while (length === 0) {\n        if (await extend()) {\n          return;\n        }\n      }\n      if (buf[ptr] !== boundary.charCodeAt(i)) {\n        console.log(\"boundary.charCode\", buf[ptr], boundary.charCodeAt(i), i);\n        throw new Error(\"Invalid boundary\");\n      }\n      ptr = (ptr + 1) % buf.length;\n      length--;\n    }\n\n    // read the boundary terminator\n    for (const c of [\"\\r\", \"\\n\"]) {\n      while (length === 0) {\n        if (await extend()) {\n          return;\n        }\n      }\n      if (buf[ptr] === c.charCodeAt(0)) {\n        ptr = (ptr + 1) % buf.length;\n        length--;\n      } else if (buf[ptr] === \"-\".charCodeAt(0)) {\n        // eof\n        return;\n      } else {\n        // invalid boundary\n        throw new Error(\"Invalid boundary\");\n      }\n    }\n\n    // read headers\n    let lastByte = 0;\n    let header: number[] = [];\n    while (true) {\n      while (length === 0) {\n        if (await extend()) {\n          return;\n        }\n      }\n      const byte = buf[ptr];\n      ptr = (ptr + 1) % buf.length;\n      length--;\n      if (lastByte === \"\\r\".charCodeAt(0) && byte === \"\\n\".charCodeAt(0)) {\n        // end of header\n        if (header.length === 1 /* it's an \\r */) {\n          // end of headers\n          break;\n        } else {\n          const decoded = new TextDecoder().decode(new Uint8Array(header));\n          const tokens = decoded.split(\":\", 2);\n          if (tokens.length !== 2) {\n            throw new Error(`Invalid header: ${decoded}`);\n          }\n          const [key, value] = tokens;\n          headers[key.trim()] = value.trim();\n          header.length = 0;\n        }\n      } else {\n        header.push(byte);\n      }\n      lastByte = byte;\n    }\n\n    // read body\n    // read the Content-Range header\n    if (!headers[\"Content-Range\"]) {\n      // TODO: read until the next boundary\n      throw new Error(\"Missing Content-Range header\");\n    }\n    const [unit, start, end] = parseContentRangeHeader(\n      headers[\"Content-Range\"],\n    );\n    if (unit !== \"bytes\") {\n      throw new Error(\"Invalid Content-Range header\");\n    }\n    const contentLength = end - start + 1;\n    const data = new Uint8Array(contentLength);\n    for (let i = 0; i < contentLength; i++) {\n      while (length === 0) {\n        if (await extend()) {\n          return;\n        }\n      }\n      data[i] = buf[ptr];\n      ptr = (ptr + 1) % buf.length;\n      length--;\n    }\n    yield { data: data.buffer, headers };\n    headers = {};\n\n    // read the trailing \\r\\n\n    for (const c of [\"\\r\", \"\\n\"]) {\n      while (length === 0) {\n        if (await extend()) {\n          return;\n        }\n      }\n      if (buf[ptr] === c.charCodeAt(0)) {\n        ptr = (ptr + 1) % buf.length;\n        length--;\n      } else {\n        // invalid boundary\n        throw new Error(\"Invalid boundary\");\n      }\n    }\n  }\n}\n", "/**\n * RangeResolver is a function that takes a range of bytes and returns a promise\n * that resolves to an ArrayBuffer containing the bytes in that range. Note that\n * the range is inclusive.\n *\n * Additionally, the RangeResolver must return a checksum which is computed from\n * the source data. This checksum is used to verify that the data has not been\n * changed between requests. The checksum can be any type, for example it is\n * valid to use the last modified timestamp of the source data or the total\n * length of the data. This checksum is passed to the RangeResolver on future\n * requests as the `checksum` argument. If it does not match the checksum when\n * reading the data, the RangeResolver should throw a LengthIntegrityError.\n *\n * @see LengthIntegrityError\n */\nexport type RangeResolver = (\n  args: {\n    start: number;\n    end: number;\n    expectedLength?: number;\n  }[],\n) => Promise<\n  {\n    data: ArrayBuffer;\n    totalLength: number;\n  }[]\n>;\n\n/**\n * LengthIntegrityError is thrown by a RangeResolver when the length argument is\n * inconsistent with the data returned. This is used to detect when the data has\n * changed between requests.\n *\n * When a LengthIntegrityError is thrown, typically the cache is evicted and the\n * query will be tried again with the exception of the data file where the error\n * is ignored due to the assumed immutability of the data file.\n *\n * @see RangeResolver\n */\nexport class LengthIntegrityError extends Error {\n  constructor() {\n    super(\"length integrity error\");\n  }\n}\n", "import { Config } from \".\";\nimport parseMultipartBody from \"./multipart\";\nimport { LengthIntegrityError } from \"./resolver\";\n\nasync function resolveIndividualPromises(\n  url: string,\n  ranges: { start: number; end: number; expectedLength?: number }[],\n) {\n  // fallback to resolving ranges individually\n  const individualRangePromises = ranges.map(\n    async ({ start, end, expectedLength }) => {\n      const rangeHeader = `${start}-${end}`;\n      const res = await fetch(url, {\n        headers: { Range: `bytes=${rangeHeader}` },\n      });\n\n      const totalLength = Number(\n        res.headers.get(\"Content-Range\")!.split(\"/\")[1],\n      );\n      if (expectedLength && totalLength !== expectedLength) {\n        throw new LengthIntegrityError();\n      }\n      return {\n        data: await res.arrayBuffer(),\n        totalLength: totalLength,\n      };\n    },\n  );\n  return await Promise.all(individualRangePromises);\n}\n\nexport async function requestRanges(\n  url: string,\n  ranges: { start: number; end: number; expectedLength?: number }[],\n  config: Config,\n): Promise<{ data: ArrayBuffer; totalLength: number }[]> {\n  const { useMultipartByteRanges } = config;\n  if (useMultipartByteRanges === false) {\n    return await resolveIndividualPromises(url, ranges);\n  }\n\n  const rangesHeader = ranges\n    .map(({ start, end }) => `${start}-${end}`)\n    .join(\",\");\n\n  const response = await fetch(url, {\n    headers: {\n      Range: `bytes=${rangesHeader}`,\n      Accept: \"multipart/bytesranges\",\n    },\n  });\n\n  switch (response.status) {\n    case 200:\n      console.warn(\n        `useMultipartByteRanges is enabled but the server indicated did not respond with a subset of bytes. Set useMultipartByteRanges: false in your Appendable config object.`,\n      );\n      return await resolveIndividualPromises(url, ranges);\n    case 206:\n      const contentType = response.headers.get(\"Content-Type\");\n      if (!contentType) {\n        throw new Error(\"Missing Content-Type in response\");\n      }\n      if (contentType.includes(\"multipart/byteranges\")) {\n        let chunks = [];\n\n        if (!response.body) {\n          throw new Error(`response body is null: ${response.body}`);\n        }\n\n        for await (const chunk of parseMultipartBody(\n          contentType,\n          response.body,\n        )) {\n          chunks.push(chunk);\n        }\n\n        // the last element is null since the final boundary marker is followed by another delim.\n        if (chunks[chunks.length - 1].data === undefined) {\n          chunks.pop();\n        }\n\n        return chunks.map(({ data, headers }) => {\n          const totalLengthStr = headers[\"content-range\"]?.split(\"/\")[1];\n          const totalLength = totalLengthStr ? parseInt(totalLengthStr, 10) : 0;\n\n          return { data, totalLength };\n        });\n      } else if (response.headers.has(\"Content-Range\")) {\n        const abuf = await response.arrayBuffer();\n        const totalLength = Number(\n          response.headers.get(\"Content-Range\")!.split(\"/\")[1],\n        );\n        return [\n          {\n            data: abuf,\n            totalLength: totalLength,\n          },\n        ];\n      } else {\n        throw new Error(`Unexpected response format: ${contentType}`);\n      }\n    case 416:\n      const requestedRange = response.headers.get(\"Range\") || rangesHeader;\n      throw new Error(\n        `Resolver cannot serve the requested ranges: ${requestedRange}`,\n      );\n    default:\n      throw new Error(`Expected 206 or 200 response, got ${response.status}`);\n  }\n}\n", "import { Config } from \".\";\nimport { requestRanges } from \"./range-request\";\nimport { RangeResolver } from \"./resolver\";\n\nexport class DataFile {\n  private originalResolver?: RangeResolver;\n\n  private constructor(private resolver: RangeResolver) {}\n\n  static forUrl(url: string, config: Config) {\n    return DataFile.forResolver(\n      async (ranges) => await requestRanges(url, ranges, config),\n    );\n  }\n\n  static forResolver(resolver: RangeResolver) {\n    const instance = new DataFile(async (ranges) => {\n      const result = await resolver(ranges);\n      return result;\n    });\n    instance.originalResolver = resolver;\n    return instance;\n  }\n\n  getResolver(): RangeResolver | undefined {\n    return this.originalResolver;\n  }\n\n  async get(start: number, end: number) {\n    const res = await this.resolver([{ start, end }]);\n    return new TextDecoder().decode(res[0].data);\n  }\n}\n", "export enum FileFormat {\n  JSONL = 0,\n  CSV = 1,\n}\n\nexport type FileMeta = {\n  version: number;\n  format: FileFormat;\n  readOffset: bigint;\n};\n\nexport async function readFileMeta(buffer: ArrayBuffer): Promise<FileMeta> {\n  if (buffer.byteLength !== 10) {\n    throw new Error(\n      `incorrect byte length! Want: 10, got ${buffer.byteLength}`,\n    );\n  }\n\n  const dataView = new DataView(buffer);\n\n  const version = dataView.getUint8(0);\n  const formatByte = dataView.getUint8(1);\n\n  if (Object.values(FileFormat).indexOf(formatByte) === -1) {\n    throw new Error(`unexpected file format. Got: ${formatByte}`);\n  }\n\n  const readOffset = dataView.getBigUint64(2, true);\n\n  return {\n    version,\n    format: formatByte,\n    readOffset,\n  };\n}\n\nexport type IndexMeta = {\n  fieldName: string;\n  fieldType: number;\n};\n\nexport type IndexHeader = {\n  fieldName: string;\n  fieldTypes: number[];\n};\n\nexport async function readIndexMeta(buffer: ArrayBuffer): Promise<IndexMeta> {\n  if (buffer.byteLength < 4) {\n    throw new Error(`invalid metadata size ${buffer.byteLength}`);\n  }\n\n  const dataView = new DataView(buffer);\n  const fieldType = dataView.getUint16(0, true);\n  const nameLength = dataView.getUint16(2, true);\n\n  if (buffer.byteLength < 4 + nameLength) {\n    throw new Error(`invalid metadata size ${buffer.byteLength}`);\n  }\n\n  const fieldNameBuffer = buffer.slice(4, 4 + nameLength);\n  const fieldName = new TextDecoder(\"utf-8\").decode(fieldNameBuffer);\n\n  return {\n    fieldName,\n    fieldType,\n  };\n}\n\nexport function collectIndexMetas(indexMetas: IndexMeta[]): IndexHeader[] {\n  const headersMap: Map<string, number[]> = new Map();\n\n  for (const meta of indexMetas) {\n    if (!headersMap.has(meta.fieldName)) {\n      headersMap.set(meta.fieldName, [meta.fieldType]);\n    } else {\n      const updatedTypes = headersMap.get(meta.fieldName);\n      updatedTypes?.push(meta.fieldType);\n      headersMap.set(meta.fieldName, updatedTypes!!);\n    }\n  }\n\n  const indexHeaders: IndexHeader[] = [];\n  headersMap.forEach((fieldTypes, fieldName) => {\n    indexHeaders.push({ fieldName, fieldTypes });\n  });\n\n  return indexHeaders;\n}\n", "import { FieldType } from \"../db/database\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { RangeResolver } from \"../resolver\";\nimport { ReferencedValue } from \"./bptree\";\n\nexport const pageSizeBytes = 4096;\n\nexport type MemoryPointer = { offset: bigint; length: number };\nexport class BPTreeNode {\n  public keys: ReferencedValue[];\n  public leafPointers: MemoryPointer[];\n  public internalPointers: bigint[];\n  private readonly dataFileResolver: RangeResolver;\n  private fileFormat: FileFormat;\n  private pageFieldType: FieldType;\n\n  constructor(\n    keys: ReferencedValue[],\n    leafPointers: MemoryPointer[],\n    internalPointers: bigint[],\n    dataFileResolver: RangeResolver,\n    fileFormat: FileFormat,\n    pageFieldType: FieldType,\n  ) {\n    this.keys = keys;\n    this.leafPointers = leafPointers;\n    this.internalPointers = internalPointers;\n    this.dataFileResolver = dataFileResolver;\n    this.fileFormat = fileFormat;\n    this.pageFieldType = pageFieldType;\n  }\n\n  leaf(): boolean {\n    return this.leafPointers.length > 0;\n  }\n\n  pointer(i: number): MemoryPointer {\n    if (this.leaf()) {\n      return this.leafPointers[i];\n    }\n\n    return {\n      offset: this.internalPointers[i],\n      length: 0, // disregard since this is a free value in golang version\n    };\n  }\n\n  numPointers(): number {\n    return this.internalPointers.length + this.leafPointers.length;\n  }\n\n  size(): bigint {\n    let size = 4;\n\n    for (let idx = 0; idx <= this.keys.length - 1; idx++) {\n      const k = this.keys[idx];\n      if (k.dataPointer.length > 0) {\n        size += 4 + 12;\n      } else {\n        size += 4 * k.value.byteLength;\n      }\n    }\n\n    for (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n      size += 12;\n    }\n    for (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n      size += 8;\n    }\n\n    return BigInt(size);\n  }\n\n  async unmarshalBinary(buffer: ArrayBuffer) {\n    let dataView = new DataView(buffer);\n    let size = dataView.getUint32(0, true);\n\n    if (size > 2147483647) {\n      size = size - 4294967296;\n    }\n\n    const leaf = size < 0;\n\n    if (leaf) {\n      this.leafPointers = new Array<MemoryPointer>(-size)\n        .fill({ offset: 0n, length: 0 })\n        .map(() => ({\n          offset: 0n,\n          length: 0,\n        }));\n      this.keys = new Array(-size)\n        .fill(null)\n        .map(\n          () =>\n            new ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0)),\n        );\n    } else {\n      this.internalPointers = Array<bigint>(size + 1)\n        .fill(0n)\n        .map(() => 0n);\n      this.keys = new Array(size)\n        .fill(null)\n        .map(\n          () =>\n            new ReferencedValue({ offset: 0n, length: 0 }, new ArrayBuffer(0)),\n        );\n    }\n\n    if (size === 0) {\n      throw new Error(\"empty node\");\n    }\n\n    let dpRanges = [];\n    let dpIndexes: number[] = [];\n\n    let m = 4;\n    for (let idx = 0; idx <= this.keys.length - 1; idx++) {\n      dataView = new DataView(buffer, m);\n      const dpOffset = dataView.getBigUint64(0, true);\n      const dpLength = dataView.getUint32(8, true);\n      m += 12;\n\n      const l = dataView.getUint32(12, true);\n      m += 4;\n\n      this.keys[idx].setDataPointer({ offset: dpOffset, length: dpLength });\n      if (l === ~0 >>> 0) {\n        const dp = this.keys[idx].dataPointer;\n\n        dpRanges.push({\n          start: Number(dp.offset),\n          end: Number(dp.offset) + dp.length - 1,\n        });\n\n        dpIndexes.push(idx);\n      } else {\n        // we are storing the values directly in the referenced value\n        const value = buffer.slice(m, m + l);\n        this.keys[idx].setValue(value);\n        m += value.byteLength;\n      }\n    }\n\n    if (dpRanges.length > 0) {\n      const res = await this.dataFileResolver(dpRanges);\n      res.forEach((res, index) => {\n        const dpIndex = dpIndexes[index];\n        const { data } = res;\n\n        const parsedData = this.parseValue(data);\n        this.keys[dpIndex].setValue(parsedData);\n      });\n    }\n\n    for (let idx = 0; idx <= this.leafPointers.length - 1; idx++) {\n      dataView = new DataView(buffer, m);\n      this.leafPointers[idx].offset = dataView.getBigUint64(0, true);\n      this.leafPointers[idx].length = dataView.getUint32(8, true);\n\n      m += 12;\n    }\n\n    for (let idx = 0; idx <= this.internalPointers.length - 1; idx++) {\n      dataView = new DataView(buffer, m);\n      this.internalPointers[idx] = dataView.getBigUint64(0, true);\n\n      m += 8;\n    }\n  }\n\n  parseValue(incomingData: ArrayBuffer): ArrayBuffer {\n    const stringData = new TextDecoder().decode(incomingData);\n\n    switch (this.fileFormat) {\n      case FileFormat.JSONL:\n        const jValue = JSON.parse(stringData);\n\n        switch (this.pageFieldType) {\n          case FieldType.Null:\n            if (jValue !== null) {\n              throw new Error(`unrecognized value for null type: ${jValue}`);\n            }\n            return new ArrayBuffer(0);\n\n          case FieldType.Boolean:\n            return new Uint8Array([jValue ? 1 : 0]).buffer;\n\n          case FieldType.Float64:\n          case FieldType.Int64:\n          case FieldType.Uint64:\n            const floatBuf = new ArrayBuffer(8);\n            let floatBufView = new DataView(floatBuf);\n            floatBufView.setFloat64(0, jValue);\n\n            return floatBuf;\n\n          case FieldType.String:\n            const e = new TextEncoder().encode(jValue);\n            return e.buffer;\n\n          default:\n            throw new Error(\n              `Unexpected Field Type. Got: ${this.pageFieldType}`,\n            );\n        }\n\n      case FileFormat.CSV:\n        return incomingData;\n    }\n  }\n\n  static async fromMemoryPointer(\n    mp: MemoryPointer,\n    resolver: RangeResolver,\n    dataFilePointer: RangeResolver,\n    fileFormat: FileFormat,\n    pageFieldType: FieldType,\n  ): Promise<{ node: BPTreeNode; bytesRead: number }> {\n    const res = await resolver([\n      {\n        start: Number(mp.offset),\n        end: Number(mp.offset) + 4096 - 1,\n      },\n    ]);\n    const { data: bufferData } = res[0];\n    const node = new BPTreeNode(\n      [],\n      [],\n      [],\n      dataFilePointer,\n      fileFormat,\n      pageFieldType,\n    );\n\n    await node.unmarshalBinary(bufferData);\n\n    return { node, bytesRead: pageSizeBytes };\n  }\n}\n", "import { BPTree, ReferencedValue } from \"./bptree\";\nimport { BPTreeNode, MemoryPointer } from \"./node\";\n\nexport type TraversalRecord = {\n  node: BPTreeNode;\n  index: number;\n  pointer: MemoryPointer;\n};\n\nexport class TraversalIterator {\n  private tree: BPTree;\n  private key: ReferencedValue;\n  private records: TraversalRecord[];\n\n  constructor(tree: BPTree, key: ReferencedValue) {\n    this.tree = tree;\n    this.key = key;\n    this.records = []; // note this works iff all records are non-empty\n  }\n\n  async init(): Promise<boolean> {\n    const rootResponse = await this.tree.root();\n\n    if (rootResponse.rootNode === null) {\n      return false;\n    }\n\n    const root = rootResponse.rootNode;\n    const offset = rootResponse.pointer;\n    const path = await this.tree.traverse(this.key, root, offset);\n    this.records = path;\n    return true;\n  }\n\n  getKey(): ReferencedValue {\n    return this.records[0].node.keys[this.records[0].index];\n  }\n\n  getPointer(): MemoryPointer {\n    return this.records[0].node.pointer(this.records[0].index);\n  }\n\n  async increment(i: number, delta: number): Promise<boolean> {\n    if (i === this.records.length) {\n      return false;\n    }\n\n    this.records[i].index += delta;\n    const rolloverLeft = this.records[i].index < 0;\n    const rolloverRight =\n      this.records[i].index >= this.records[i].node.numPointers();\n\n    if (rolloverLeft || rolloverRight) {\n      if (!this.increment(i + 1, delta)) {\n        return false;\n      }\n\n      if (!this.records[i + 1]) {\n        return false;\n      }\n      const node = await this.tree.readNode(\n        this.records[i + 1].node.pointer(this.records[i + 1].index),\n      );\n\n      // propagate the rollover\n      this.records[i].node = node;\n\n      if (rolloverLeft) {\n        this.records[i].index = this.records[i].node.numPointers() - 1;\n      } else {\n        this.records[i].index = 0;\n      }\n    }\n\n    return true;\n  }\n\n  async next(): Promise<boolean> {\n    if (this.records.length === 0) {\n      return await this.init();\n    }\n\n    return this.increment(0, 1);\n  }\n\n  async prev(): Promise<boolean> {\n    if (this.records.length === 0) {\n      const res = await this.init();\n      if (!res) {\n        return false;\n      }\n    }\n\n    return this.increment(0, -1);\n  }\n}\n", "import { BPTreeNode, MemoryPointer } from \"./node\";\nimport { RangeResolver } from \"../resolver\";\nimport { TraversalIterator, TraversalRecord } from \"./traversal\";\nimport { FileFormat } from \"../index-file/meta\";\nimport { FieldType } from \"../db/database\";\n\nexport interface MetaPage {\n  root(): Promise<MemoryPointer>;\n}\n\ntype RootResponse = {\n  rootNode: BPTreeNode | null;\n  pointer: MemoryPointer;\n};\n\nexport class BPTree {\n  private readonly tree: RangeResolver;\n  private meta: MetaPage;\n  private readonly dataFileResolver: RangeResolver;\n  private fileFormat: FileFormat;\n  private pageFieldType: FieldType;\n\n  constructor(\n    tree: RangeResolver,\n    meta: MetaPage,\n    dataFileResolver: RangeResolver,\n    fileFormat: FileFormat,\n    pageFieldType: FieldType,\n  ) {\n    this.tree = tree;\n    this.meta = meta;\n    this.dataFileResolver = dataFileResolver;\n    this.fileFormat = fileFormat;\n    this.pageFieldType = pageFieldType;\n  }\n\n  async root(): Promise<RootResponse> {\n    const mp = await this.meta.root();\n\n    if (!mp || mp.length === 0) {\n      return {\n        rootNode: null,\n        pointer: mp,\n      };\n    }\n\n    const root = await this.readNode(mp);\n    if (!root) {\n      return {\n        rootNode: null,\n        pointer: mp,\n      };\n    }\n\n    return {\n      rootNode: root,\n      pointer: mp,\n    };\n  }\n\n  async readNode(ptr: MemoryPointer): Promise<BPTreeNode> {\n    try {\n      const { node, bytesRead } = await BPTreeNode.fromMemoryPointer(\n        ptr,\n        this.tree,\n        this.dataFileResolver,\n        this.fileFormat,\n        this.pageFieldType,\n      );\n\n      if (!bytesRead) {\n        throw new Error(\"bytes read do not line up\");\n      }\n\n      return node;\n    } catch (error) {\n      throw new Error(`${error}`);\n    }\n  }\n\n  public iter(key: ReferencedValue): TraversalIterator {\n    return new TraversalIterator(this, key);\n  }\n\n  async first(): Promise<ReferencedValue> {\n    let { rootNode } = await this.root();\n    if (!rootNode) {\n      throw new Error(\"unable to get root node\");\n    }\n\n    let currNode = await this.readNode(rootNode.pointer(0));\n\n    while (!currNode.leaf()) {\n      const childPointer = currNode.pointer(0);\n      currNode = await this.readNode(childPointer);\n    }\n\n    return currNode.keys[0];\n  }\n\n  async last(): Promise<ReferencedValue> {\n    let { rootNode } = await this.root();\n    if (!rootNode) {\n      throw new Error(\"unable to get root node\");\n    }\n\n    let currNode = await this.readNode(\n      rootNode.pointer(rootNode.numPointers() - 1),\n    );\n\n    while (!currNode.leaf()) {\n      const childPointer = currNode.pointer(currNode.numPointers() - 1);\n      currNode = await this.readNode(childPointer);\n    }\n\n    return currNode.keys[currNode.keys.length - 1];\n  }\n\n  async traverse(\n    key: ReferencedValue,\n    node: BPTreeNode,\n    pointer: MemoryPointer,\n  ): Promise<TraversalRecord[]> {\n    let [index, found] = binarySearchReferencedValues(node.keys, key);\n    if (node.leaf()) {\n      return [{ node, index, pointer }];\n    }\n\n    if (found) {\n      index += 1;\n    }\n\n    const childPointer = node.pointer(index);\n    const child = await this.readNode(childPointer);\n    const path = await this.traverse(key, child, childPointer);\n\n    return [...path, { node, index, pointer }];\n  }\n\n  public async find(\n    key: ReferencedValue,\n  ): Promise<[ReferencedValue, MemoryPointer]> {\n    const p = this.iter(key);\n\n    if (!(await p.next())) {\n      return [\n        new ReferencedValue(\n          { offset: 0n, length: 0 },\n          new Uint8Array(0).buffer,\n        ),\n        { offset: 0n, length: 0 },\n      ];\n    }\n\n    return [p.getKey(), p.getPointer()];\n  }\n}\n\nexport class ReferencedValue {\n  public dataPointer: MemoryPointer;\n  public value: ArrayBuffer;\n\n  constructor(dataPointer: MemoryPointer, value: ArrayBuffer) {\n    this.dataPointer = dataPointer;\n    this.value = value;\n  }\n\n  setDataPointer(mp: MemoryPointer) {\n    this.dataPointer = mp;\n  }\n\n  setValue(value: ArrayBuffer) {\n    this.value = value;\n  }\n\n  static compareBytes(aBuffer: ArrayBuffer, bBuffer: ArrayBuffer): number {\n    const a = new Uint8Array(aBuffer);\n    const b = new Uint8Array(bBuffer);\n\n    const len = Math.min(a.length, b.length);\n    for (let idx = 0; idx < len; idx++) {\n      if (a[idx] !== b[idx]) {\n        return a[idx] < b[idx] ? -1 : 1;\n      }\n    }\n\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    return 0;\n  }\n}\n\nfunction compareReferencedValues(\n  a: ReferencedValue,\n  b: ReferencedValue,\n): number {\n  const valueComparison = ReferencedValue.compareBytes(a.value, b.value);\n  if (valueComparison !== 0) {\n    return valueComparison;\n  }\n\n  if (a.dataPointer.offset > b.dataPointer.offset) {\n    return 1;\n  } else if (a.dataPointer.offset < b.dataPointer.offset) {\n    return -1;\n  }\n\n  if (a.dataPointer.length > b.dataPointer.length) {\n    return 1;\n  } else if (a.dataPointer.length < b.dataPointer.length) {\n    return -1;\n  }\n\n  return 0;\n}\n\nexport function binarySearchReferencedValues(\n  values: ReferencedValue[],\n  target: ReferencedValue,\n): [number, boolean] {\n  const n = values.length;\n\n  let i = 0;\n  let j = n;\n\n  while (i < j) {\n    const h = Math.floor((i + j) / 2);\n\n    if (compareReferencedValues(values[h], target) < 0) {\n      i = h + 1;\n    } else {\n      j = h;\n    }\n  }\n\n  return [i, i < n && compareReferencedValues(values[i], target) === 0];\n}\n", "import { RangeResolver } from \"../resolver\";\nimport { MemoryPointer } from \"./node\";\n\nexport const N = 16;\nexport const PAGE_SIZE_BYTES = 4096;\nexport const maxUint64 = 2n ** 64n - 1n;\n\nexport class LinkedMetaPage {\n  private resolver: RangeResolver;\n  private offset: bigint;\n  private metaPageData?: ArrayBuffer;\n  private metaPageDataPromise?: Promise<\n    { data: ArrayBuffer; totalLength: number }[]\n  >;\n\n  constructor(resolver: RangeResolver, offset: bigint, data?: ArrayBuffer) {\n    this.resolver = resolver;\n    this.offset = offset;\n    this.metaPageData = data;\n  }\n\n  async root(): Promise<MemoryPointer> {\n    const pageData = await this.getMetaPage();\n\n    // we seek by 12 bytes since offset is 8 bytes, length is 4 bytes\n    const data = pageData.slice(0, 12);\n    const view = new DataView(data);\n\n    const pointerOffset = view.getBigUint64(0, true);\n    const lengthOffset = view.getUint32(8, true);\n\n    return {\n      offset: pointerOffset,\n      length: lengthOffset,\n    };\n  }\n\n  async metadata(): Promise<ArrayBuffer> {\n    const pageData = await this.getMetaPage();\n\n    const lengthView = new DataView(pageData, 8 * N + 16);\n\n    // read the first four because that represents length\n    const metadataLength = lengthView.getUint32(0, true);\n    const start = 8 * N + 20;\n\n    return pageData.slice(start, start + metadataLength);\n  }\n\n  public setMetaPage(pageData: ArrayBuffer) {\n    this.metaPageData = pageData;\n  }\n\n  private async getMetaPage(): Promise<ArrayBuffer> {\n    if (this.metaPageData) {\n      return this.metaPageData;\n    }\n\n    if (!this.metaPageDataPromise) {\n      this.metaPageDataPromise = this.resolver([\n        {\n          start: Number(this.offset),\n          end: Number(this.offset) + PAGE_SIZE_BYTES - 1,\n        },\n      ]);\n    }\n\n    const res = await this.metaPageDataPromise;\n    const { data } = res[0];\n\n    return data;\n  }\n\n  async nextNOffsets(): Promise<bigint[]> {\n    const pageData = await this.getMetaPage();\n    const view = new DataView(pageData, 12);\n    let offsets: bigint[] = [];\n\n    for (let idx = 0; idx <= N - 1; idx++) {\n      const nextOffset = view.getBigUint64(idx * 8, true);\n\n      if (nextOffset === maxUint64) {\n        return offsets;\n      }\n      offsets.push(nextOffset);\n    }\n\n    return offsets;\n  }\n\n  getOffset(): bigint {\n    return this.offset;\n  }\n}\n\nexport function ReadMultiBPTree(\n  resolver: RangeResolver,\n  idx: number,\n): LinkedMetaPage {\n  let offset = idx < 0 ? BigInt(0) : BigInt(idx + 1) * BigInt(PAGE_SIZE_BYTES);\n  return new LinkedMetaPage(resolver, offset);\n}\n", "import { Database, OrderBy, Query, Schema, WhereNode } from \"./database\";\n\n/**\n * A class for building and executing database queries in a flexible API style.\n * Allows chaining methods for 'where', 'orderBy', 'select', and 'limit' clauses.\n */\nexport class QueryBuilder<T extends Schema> {\n  private queryObject: Query<T> = {\n    where: [],\n    orderBy: undefined,\n    select: undefined,\n    limit: undefined,\n  };\n\n  /**\n   * Initializes a new instance of the QueryBuilder class.\n   * @param {Database<T>} database - An Appendable database instance to execute queries against.\n   */\n  constructor(private database: Database<T>) {}\n\n  /**\n   * Retrieves an immutable copy of the current query.\n   *\n   * @returns {Query<T>} The Query instance.\n   */\n  toQuery(): Query<T> {\n    return {\n      where: this.queryObject.where ? [...this.queryObject.where] : [],\n      orderBy: this.queryObject.orderBy\n        ? [...this.queryObject.orderBy]\n        : undefined,\n      select: this.queryObject.select\n        ? [...this.queryObject.select]\n        : undefined,\n      limit: this.queryObject.limit,\n    };\n  }\n\n  /**\n   * Executes the constructed query\n   */\n  get() {\n    return this.database.query(this.queryObject);\n  }\n\n  /**\n   * Adds a 'where' clause to the query.\n   *\n   * @param {keyof T} key - The index header's field name to apply the 'where' condition.\n   * @param {WhereNode<T>[\"operation\"]} operation - The comparison relation (e.g., >=, <=, ==, >=, >).\n   * @param {T[keyof T]} value - The value to compare against.\n   * @returns {QueryBuilder<T>} The QueryBuilder instance.\n   */\n  where(\n    key: keyof T,\n    operation: WhereNode<T>[\"operation\"],\n    value: T[keyof T],\n  ): QueryBuilder<T> {\n    const newQuery = new QueryBuilder<T>(this.database);\n    newQuery.queryObject = {\n      ...this.queryObject,\n      where: [...(this.queryObject.where || []), { key, operation, value }],\n    };\n    return newQuery;\n  }\n  /**\n   * Adds an 'orderBy' clause to the query.\n   *\n   * @param {keyof T} key - The index header's field name to order by.\n   * @param {OrderBy<T>[\"direction\"]} direction - The sorting direction (e.g., ASC, DESC).\n   * @returns {QueryBuilder<T>} The QueryBuilder instance.\n   */\n  orderBy(key: keyof T, direction: OrderBy<T>[\"direction\"]): QueryBuilder<T> {\n    const newQuery = new QueryBuilder<T>(this.database);\n    newQuery.queryObject = {\n      ...this.queryObject,\n      orderBy: [...(this.queryObject.orderBy || []), { key, direction }],\n    };\n    return newQuery;\n  }\n\n  /**\n   * Specifies the fields to be selected in the query.\n   *\n   * @param {(keyof T)[]} keys - A list of index header field names.\n   * @returns {QueryBuilder<T>} The QueryBuilder instance.\n   */\n  select(keys: (keyof T)[]): QueryBuilder<T> {\n    const newQuery = new QueryBuilder<T>(this.database);\n    newQuery.queryObject = {\n      ...this.queryObject,\n      select: keys,\n    };\n    return newQuery;\n  }\n\n  /**\n   * Limits the number of records returned by the query.\n   *\n   * @param {number} limit - The maximum number of records to return.\n   * @returns {QueryBuilder<T>} The QueryBuilder instance.\n   */\n  limit(limit: number): QueryBuilder<T> {\n    const newQuery = new QueryBuilder<T>(this.database);\n    newQuery.queryObject = {\n      ...this.queryObject,\n      limit: limit,\n    };\n    return newQuery;\n  }\n}\n", "import { FieldType, OrderBy, Schema } from \"./database\";\n\ntype QueryWhere = {\n  valueBuf: ArrayBuffer;\n  fieldType: FieldType;\n};\n\nexport function processWhere<T>(value: T[keyof T]): QueryWhere | null {\n  let valueBuf: ArrayBuffer;\n\n  if (value === null) {\n    return {\n      fieldType: FieldType.Null,\n      valueBuf: new ArrayBuffer(0),\n    };\n  } else {\n    switch (typeof value) {\n      case \"bigint\":\n      case \"number\":\n        valueBuf = new ArrayBuffer(8);\n        new DataView(valueBuf).setFloat64(0, Number(value));\n        return {\n          fieldType: FieldType.Float64,\n          valueBuf,\n        };\n      case \"boolean\":\n        return {\n          fieldType: FieldType.Boolean,\n          valueBuf: new Uint8Array([value ? 1 : 0]).buffer,\n        };\n\n      case \"string\":\n        return {\n          fieldType: FieldType.String,\n          valueBuf: new TextEncoder().encode(value as string).buffer,\n        };\n    }\n  }\n\n  return null;\n}\n\nexport function handleSelect<T>(data: string, select?: (keyof T)[]) {\n  let jData = JSON.parse(data);\n  if (select && select.length > 0) {\n    return select.reduce(\n      (acc, field) => {\n        if (field in jData) {\n          acc[field] = jData[field];\n        }\n        return acc;\n      },\n      {} as Pick<T, keyof T>,\n    );\n  }\n\n  return jData;\n}\n", "import { IndexHeader, IndexMeta } from \"../index-file/meta\";\nimport {\n  FieldType,\n  OrderBy,\n  Query,\n  Schema,\n  SelectField,\n  WhereNode,\n} from \"./database\";\n\n/**\n * containsType checks if the given compositeType includes the specified singleType.\n * It uses a bitwise AND operation to determine if the singleType's bit is set in the compositeType.\n *\n * @param {bigint} compositeType - A bigint representing a composite of multiple types.\n * @param {FieldType} singleType - The specific type to check for within the compositeType.\n * @returns {boolean} - Returns true if singleType is included in compositeType, false otherwise.\n */\nfunction checkType(headerType: number[], queryType: FieldType): boolean {\n  return headerType.includes(queryType);\n}\n\n/**\n * validateWhere validates the 'where' clause of the query.\n *\n * @param {WhereNode<T>[] | undefined} where - The 'where' clause to validate.\n * @param {IndexMeta[]} headers - List of headers to check field existence and type compatibility.\n * @throws {Error} - Throws an error if the 'where' clause is missing, invalid, or refers to non-existent fields.\n */\nfunction validateWhere<T extends Schema>(\n  where: WhereNode<T>[] | undefined,\n  headers: IndexHeader[],\n): void {\n  if (!where || !Array.isArray(where) || where.length === 0) {\n    throw new Error(\"Missing 'where' clause.\");\n  }\n\n  for (const whereNode of where) {\n    if (![\"<\", \"<=\", \"==\", \">=\", \">\"].includes(whereNode.operation)) {\n      throw new Error(\"Invalid operation in 'where' clause.\");\n    }\n\n    if (typeof whereNode.key !== \"string\") {\n      throw new Error(\"'key' in 'where' clause must be a string.\");\n    }\n\n    const header = headers.find((h) => h.fieldName === whereNode.key);\n\n    if (!header) {\n      throw new Error(\n        `key: ${whereNode.key} in 'where' clause does not exist in dataset.`,\n      );\n    }\n\n    if (typeof whereNode.value === \"undefined\") {\n      throw new Error(\"'value' in 'where' clause is missing.\");\n    }\n\n    const headerType = header.fieldTypes;\n\n    if (whereNode.value === null) {\n      if (!checkType(headerType, FieldType.Null)) {\n        throw new Error(\n          `null type not included in ${whereNode.key}'s header types.`,\n        );\n      }\n    } else {\n      switch (typeof whereNode.value) {\n        case \"bigint\":\n        case \"number\":\n          if (\n            !checkType(headerType, FieldType.Float64) &&\n            !checkType(headerType, FieldType.Uint64) &&\n            !checkType(headerType, FieldType.Int64)\n          ) {\n            throw new Error(\n              `number type not included in ${whereNode.key}'s header types.`,\n            );\n          }\n          break;\n\n        case \"string\":\n          if (!checkType(headerType, FieldType.String)) {\n            throw new Error(\n              `string type not included in ${whereNode.key}'s header types`,\n            );\n          }\n          break;\n\n        case \"boolean\":\n          if (!checkType(headerType, FieldType.Boolean)) {\n            throw new Error(\n              `boolean type not included in ${whereNode.key}'s header types`,\n            );\n          }\n          break;\n\n        default:\n          throw new Error(\n            `unrecognized type: ${typeof whereNode.value} not included in ${whereNode.key}'s header types`,\n          );\n      }\n    }\n  }\n}\n\n/**\n * validateOrderBy validates the 'orderBy' clause of the query.\n * Currently supports strictly one 'orderBy' condition that must match the 'where' clause key.\n *\n * @param {OrderBy<T>[] | undefined} orderBy - The 'orderBy' clause to validate.\n * @param {string} whereKey - The key used in the 'where' clause for compatibility.\n * @throws {Error} Throws an error if the 'orderBy' clause is invalid or doesn't match the 'where' clause key.\n */\nfunction validateOrderBy<T extends Schema>(\n  orderBy: OrderBy<T>[] | undefined,\n  whereKey: string,\n): void {\n  if (orderBy) {\n    if (!Array.isArray(orderBy) || orderBy.length === 0) {\n      throw new Error(\"Invalid 'orderBy' clause.\");\n    }\n\n    // Note: currently we only support one orderBy and it must be the where clause. When we add composite indexes and complex querying, refactor.\n    const orderByObj = orderBy[0];\n\n    if (![\"ASC\", \"DESC\"].includes(orderByObj.direction)) {\n      throw new Error(\"Invalid direction in `orderBy`.\");\n    }\n\n    if (orderByObj.key !== whereKey) {\n      throw new Error(\"'key' in `orderBy` must match `key` in `where` clause\");\n    }\n  }\n}\n\n/**\n * validateSelect validates the 'select' fields of a query.\n *\n * @param {SelectField<T>[] | undefined} select - The 'select' clause to validate.\n * @param {IndexMeta[]} headers - List of headers to check for field existence.\n * @throws {Error} Throws an error if any field in the 'select' clause doesn't exist in headers.\n */\nfunction validateSelect<T extends Schema>(\n  select: SelectField<T>[] | undefined,\n  headers: IndexHeader[],\n): void {\n  if (select) {\n    if (!Array.isArray(select)) {\n      throw new Error(`select is not an array: ${select}`);\n    }\n\n    if (select.length <= 0) {\n      throw new Error(`select clause is empty: ${select}`);\n    }\n\n    let hset = new Set();\n    headers.map((h) => hset.add(h.fieldName));\n\n    select.map((s) => {\n      if (!hset.has(s)) {\n        throw new Error(\n          `${s as string} is not included in the field name headers`,\n        );\n      }\n    });\n  }\n}\n\n/**\n * validateQuery checks the structure and syntax of the query against the provided headers.\n * It ensures that the fields specified in the query are valid and exist in the headers.\n * If any part of the query is invalid (e.g., a field doesn't exist), it throws an error.\n *\n * @param {Query<T>} query - The query object to validate.\n * @param {IndexMeta[]} headers - The headers against which to validate the query fields.\n * @throws {Error} Throws an error if query is invalid.\n */\nexport function validateQuery<T extends Schema>(\n  query: Query<T>,\n  headers: IndexHeader[],\n): void {\n  // validate the query\n  validateWhere(query.where, headers);\n  validateOrderBy(query.orderBy, query.where![0].key as string);\n  validateSelect(query.select, headers);\n}\n", "import { BPTree, ReferencedValue } from \"../btree/bptree\";\nimport { maxUint64 } from \"../btree/multi\";\nimport { DataFile } from \"../data-file\";\nimport { VersionedIndexFile } from \"../index-file/index-file\";\nimport { IndexHeader, readIndexMeta } from \"../index-file/meta\";\nimport { QueryBuilder } from \"./query-builder\";\nimport { handleSelect, processWhere } from \"./query-logic\";\nimport { validateQuery } from \"./query-validation\";\n\nexport type Schema = {\n  [key: string]: {};\n};\n\nexport type WhereNode<T extends Schema, K extends keyof T = keyof T> = {\n  operation: \"<\" | \"<=\" | \"==\" | \">=\" | \">\";\n  key: keyof T;\n  value: T[K];\n};\n\nexport type OrderBy<T extends Schema> = {\n  key: keyof T;\n  direction: \"ASC\" | \"DESC\";\n};\n\nexport type SelectField<T extends Schema> = keyof T;\n\nexport type Query<T extends Schema> = {\n  where?: WhereNode<T>[];\n  orderBy?: OrderBy<T>[];\n  select?: SelectField<T>[];\n  limit?: number;\n};\n\nexport enum FieldType {\n  String = 0,\n  Int64 = 1,\n  Uint64 = 2,\n  Float64 = 3,\n  Object = 4,\n  Array = 5,\n  Boolean = 6,\n  Null = 7,\n}\n\nexport function fieldTypeToString(f: FieldType): string {\n  let str;\n  switch (f) {\n    case FieldType.String:\n      str = \"String\";\n      break;\n\n    case FieldType.Int64:\n      str = \"Int64\";\n      break;\n\n    case FieldType.Uint64:\n      str = \"Uint64\";\n      break;\n\n    case FieldType.Float64:\n      str = \"Float64\";\n      break;\n\n    case FieldType.Object:\n      str = \"Object\";\n      break;\n\n    case FieldType.Array:\n      str = \"Array\";\n      break;\n\n    case FieldType.Boolean:\n      str = \"Boolean\";\n      break;\n    case FieldType.Null:\n      str = \"Null\";\n      break;\n  }\n  return str;\n}\n\nexport class Database<T extends Schema> {\n  private indexHeadersPromise?: Promise<IndexHeader[]>;\n\n  private constructor(\n    private dataFile: DataFile,\n    private indexFile: VersionedIndexFile<T>,\n  ) {}\n\n  static forDataFileAndIndexFile<T extends Schema>(\n    dataFile: DataFile,\n    indexFile: VersionedIndexFile<T>,\n  ) {\n    return new Database(dataFile, indexFile);\n  }\n\n  async fields() {\n    if (!this.indexHeadersPromise) {\n      this.indexHeadersPromise = this.indexFile.indexHeaders();\n    }\n\n    return this.indexHeadersPromise;\n  }\n\n  async *query(query: Query<T>) {\n    if (new Set((query.where ?? []).map((where) => where.key)).size > 1) {\n      throw new Error(\"composite indexes not supported... yet\");\n    }\n\n    const { format } = await this.indexFile.metadata();\n    const dfResolver = this.dataFile.getResolver();\n    if (!dfResolver) {\n      throw new Error(\"data file is undefined\");\n    }\n\n    const headers = await this.fields();\n\n    validateQuery(query, headers);\n\n    for (const { key, value, operation } of query.where ?? []) {\n      const header = headers.find((header) => header.fieldName === key);\n      if (!header) {\n        throw new Error(\"field not found\");\n      }\n\n      const res = processWhere(value);\n      if (res === null) {\n        throw new Error(`unable to process key with a type ${typeof value}`);\n      }\n      const { fieldType, valueBuf } = res;\n\n      const mps = await this.indexFile.seek(key as string, fieldType);\n      const mp = mps[0];\n      const { fieldType: mpFieldType } = await readIndexMeta(\n        await mp.metadata(),\n      );\n\n      let ord: \"ASC\" | \"DESC\" = \"ASC\";\n      if (query.orderBy && query.orderBy[0]) {\n        ord = query.orderBy[0].direction;\n      }\n\n      const bptree = new BPTree(\n        this.indexFile.getResolver(),\n        mp,\n        dfResolver,\n        format,\n        mpFieldType,\n      );\n\n      if (operation === \">\") {\n        if (ord === \"ASC\") {\n          const valueRef = new ReferencedValue(\n            { offset: 0n, length: 0 },\n            valueBuf,\n          );\n          const iter = bptree.iter(valueRef);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) < 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const lastKey = await bptree.last();\n          const iter = bptree.iter(lastKey);\n\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) < 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      } else if (operation === \">=\") {\n        if (ord === \"ASC\") {\n          const valueRef = new ReferencedValue(\n            { offset: 0n, length: 0 },\n            valueBuf,\n          );\n          const iter = bptree.iter(valueRef);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) <= 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const lastKey = await bptree.last();\n          const iter = bptree.iter(lastKey);\n\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) <= 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      } else if (operation === \"==\") {\n        const valueRef = new ReferencedValue(\n          { offset: 0n, length: 0 },\n          valueBuf,\n        );\n        const iter = bptree.iter(valueRef);\n\n        while (await iter.next()) {\n          const currentKey = iter.getKey();\n\n          if (ReferencedValue.compareBytes(valueBuf, currentKey.value) === 0) {\n            const mp = iter.getPointer();\n\n            const data = await this.dataFile.get(\n              Number(mp.offset),\n              Number(mp.offset) + mp.length - 1,\n            );\n\n            yield handleSelect(data, query.select);\n          }\n        }\n      } else if (operation === \"<=\") {\n        if (ord === \"DESC\") {\n          const valueRef = new ReferencedValue(\n            { offset: maxUint64, length: 0 },\n            valueBuf,\n          );\n          const iter = bptree.iter(valueRef);\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) >= 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const firstKey = await bptree.first();\n          const iter = bptree.iter(firstKey);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            if (ReferencedValue.compareBytes(valueBuf, currentKey.value) >= 0) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      } else if (operation === \"<\") {\n        if (ord === \"DESC\") {\n          const valueRef = new ReferencedValue(\n            { offset: maxUint64, length: 0 },\n            valueBuf,\n          );\n          const iter = bptree.iter(valueRef);\n          while (await iter.prev()) {\n            const currentKey = iter.getKey();\n\n            if (\n              ReferencedValue.compareBytes(valueBuf, currentKey.value) === 1\n            ) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        } else {\n          const firstKey = await bptree.first();\n          const iter = bptree.iter(firstKey);\n\n          while (await iter.next()) {\n            const currentKey = iter.getKey();\n\n            if (\n              ReferencedValue.compareBytes(valueBuf, currentKey.value) === 1\n            ) {\n              const mp = iter.getPointer();\n\n              const data = await this.dataFile.get(\n                Number(mp.offset),\n                Number(mp.offset) + mp.length - 1,\n              );\n\n              yield handleSelect(data, query.select);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  where(\n    key: keyof T,\n    operation: WhereNode<T>[\"operation\"],\n    value: T[keyof T],\n  ): QueryBuilder<T> {\n    return new QueryBuilder(this).where(key, operation, value);\n  }\n}\n", "import {\n  LinkedMetaPage,\n  PAGE_SIZE_BYTES,\n  ReadMultiBPTree,\n} from \"../btree/multi\";\nimport { RangeResolver } from \"../resolver\";\nimport {\n  FileFormat,\n  IndexHeader,\n  IndexMeta,\n  collectIndexMetas,\n  readIndexMeta,\n} from \"./meta\";\nimport { FieldType } from \"../db/database\";\nimport { requestRanges } from \"../range-request\";\nimport { Config } from \"..\";\n\nexport class IndexFile {\n  static async forUrl<T = any>(url: string, config: Config) {\n    return await IndexFile.forResolver<T>(\n      async (ranges) => await requestRanges(url, ranges, config),\n    );\n  }\n\n  static async forResolver<T = any>(\n    resolver: RangeResolver,\n  ): Promise<VersionedIndexFile<T>> {\n    return new IndexFileV1<T>(resolver);\n  }\n}\n\nexport type FileMeta = {\n  version: number;\n  format: number;\n  readOffset: bigint;\n};\n\nexport interface VersionedIndexFile<T> {\n  getResolver(): RangeResolver;\n\n  tree(): Promise<LinkedMetaPage>;\n\n  metadata(): Promise<FileMeta>;\n\n  indexHeaders(): Promise<IndexHeader[]>;\n\n  seek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]>;\n\n  fetchMetaPages(): Promise<void>;\n}\n\nexport class IndexFileV1<T> implements VersionedIndexFile<T> {\n  private _tree?: LinkedMetaPage;\n\n  private linkedMetaPages: LinkedMetaPage[] = [];\n\n  constructor(private resolver: RangeResolver) {}\n\n  getResolver(): RangeResolver {\n    return this.resolver;\n  }\n\n  async tree(): Promise<LinkedMetaPage> {\n    if (this._tree) {\n      return this._tree;\n    }\n\n    const tree = ReadMultiBPTree(this.resolver, 0);\n\n    this._tree = tree;\n    return tree;\n  }\n\n  async metadata(): Promise<FileMeta> {\n    const tree = await this.tree();\n\n    const buffer = await tree.metadata();\n\n    // unmarshall binary for FileMeta\n    if (buffer.byteLength < 10) {\n      throw new Error(\n        `incorrect byte length! Want: 10, got ${buffer.byteLength}`,\n      );\n    }\n\n    const dataView = new DataView(buffer);\n    const version = dataView.getUint8(0);\n    const formatByte = dataView.getUint8(1);\n\n    if (Object.values(FileFormat).indexOf(formatByte) === -1) {\n      throw new Error(`unexpected file format. Got: ${formatByte}`);\n    }\n\n    const readOffset = dataView.getBigUint64(2, true);\n\n    return {\n      version: version,\n      format: formatByte,\n      readOffset: readOffset,\n    };\n  }\n\n  async seek(header: string, fieldType: FieldType): Promise<LinkedMetaPage[]> {\n    if (this.linkedMetaPages.length === 0) {\n      await this.fetchMetaPages();\n    }\n\n    let headerMps = [];\n\n    for (let idx = 0; idx <= this.linkedMetaPages.length - 1; idx++) {\n      const mp = this.linkedMetaPages[idx];\n      const indexMeta = await readIndexMeta(await mp.metadata());\n      if (indexMeta.fieldName === header) {\n        if (fieldType === FieldType.Float64) {\n          // if key is a number or bigint, we cast it as a float64 type\n          if (\n            indexMeta.fieldType === FieldType.Float64 ||\n            indexMeta.fieldType === FieldType.Int64 ||\n            indexMeta.fieldType === FieldType.Uint64\n          ) {\n            headerMps.push(mp);\n          }\n        } else {\n          if (indexMeta.fieldType === fieldType) {\n            headerMps.push(mp);\n          }\n        }\n      }\n    }\n\n    return headerMps;\n  }\n\n  async fetchMetaPages(): Promise<void> {\n    let currMp = await this.tree();\n    let offsets = await currMp.nextNOffsets();\n\n    while (offsets.length > 0) {\n      let ranges = offsets.map((o) => ({\n        start: Number(o),\n        end: Number(o) + PAGE_SIZE_BYTES - 1,\n      }));\n\n      let res = await this.resolver(ranges);\n      let idx = 0;\n      for (const { data } of res) {\n        this.linkedMetaPages.push(\n          new LinkedMetaPage(this.resolver, offsets[idx], data),\n        );\n        idx++;\n      }\n\n      currMp = this.linkedMetaPages[this.linkedMetaPages.length - 1];\n      offsets = await currMp.nextNOffsets();\n    }\n  }\n\n  async indexHeaders(): Promise<IndexHeader[]> {\n    if (this.linkedMetaPages.length === 0) {\n      await this.fetchMetaPages();\n    }\n\n    let indexMetas: IndexMeta[] = [];\n    for (const mp of this.linkedMetaPages) {\n      const im = await readIndexMeta(await mp.metadata());\n      indexMetas.push(im);\n    }\n\n    return collectIndexMetas(indexMetas);\n  }\n}\n", "import { DataFile } from \"./data-file\";\nimport { Database, FieldType, fieldTypeToString } from \"./db/database\";\nimport { IndexFile } from \"./index-file/index-file\";\nimport { RangeResolver } from \"./resolver\";\n\nexport type Config = {\n  useMultipartByteRanges?: boolean;\n};\n\nexport async function init(\n  dataUrl: string | RangeResolver,\n  indexUrl: string | RangeResolver,\n  config?: Config,\n) {\n  if (!config) {\n    config = { useMultipartByteRanges: true };\n  }\n\n  return Database.forDataFileAndIndexFile(\n    typeof dataUrl === \"string\"\n      ? DataFile.forUrl(dataUrl, config)\n      : DataFile.forResolver(dataUrl),\n    typeof indexUrl === \"string\"\n      ? await IndexFile.forUrl(indexUrl, config)\n      : await IndexFile.forResolver(indexUrl),\n  );\n}\n\ninterface GlobalMap {\n  Appendable: {\n    init: Function;\n    FieldType: typeof FieldType;\n    fieldTypeToString: Function;\n  };\n}\n\ndeclare global {\n  var Appendable: GlobalMap[\"Appendable\"];\n}\n\nglobalThis.Appendable = {\n  init,\n  FieldType,\n  fieldTypeToString,\n};\n"],
  "mappings": "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",
  "names": ["getReader", "stream", "residual", "readDone", "reader", "buf", "n", "result", "parseContentRangeHeader", "header", "tokens", "range", "total", "start", "end", "parseMultipartBody", "contentType", "boundaryToken", "s", "boundary", "headers", "ptr", "length", "extend", "done", "value", "i", "c", "lastByte", "byte", "decoded", "key", "unit", "contentLength", "data", "LengthIntegrityError", "resolveIndividualPromises", "url", "ranges", "individualRangePromises", "start", "end", "expectedLength", "rangeHeader", "res", "totalLength", "LengthIntegrityError", "requestRanges", "config", "useMultipartByteRanges", "rangesHeader", "response", "contentType", "chunks", "chunk", "parseMultipartBody", "data", "headers", "totalLengthStr", "abuf", "requestedRange", "DataFile", "_DataFile", "resolver", "url", "config", "ranges", "requestRanges", "instance", "start", "end", "res", "FileFormat", "readIndexMeta", "buffer", "dataView", "fieldType", "nameLength", "fieldNameBuffer", "collectIndexMetas", "indexMetas", "headersMap", "meta", "updatedTypes", "indexHeaders", "fieldTypes", "fieldName", "pageSizeBytes", "BPTreeNode", "_BPTreeNode", "keys", "leafPointers", "internalPointers", "dataFileResolver", "fileFormat", "pageFieldType", "i", "size", "idx", "k", "buffer", "dataView", "ReferencedValue", "dpRanges", "dpIndexes", "m", "dpOffset", "dpLength", "l", "dp", "value", "res", "index", "dpIndex", "data", "parsedData", "incomingData", "stringData", "jValue", "floatBuf", "mp", "resolver", "dataFilePointer", "bufferData", "node", "TraversalIterator", "tree", "key", "rootResponse", "root", "offset", "path", "i", "delta", "rolloverLeft", "rolloverRight", "node", "BPTree", "tree", "meta", "dataFileResolver", "fileFormat", "pageFieldType", "mp", "root", "ptr", "node", "bytesRead", "BPTreeNode", "error", "key", "TraversalIterator", "rootNode", "currNode", "childPointer", "pointer", "index", "found", "binarySearchReferencedValues", "child", "p", "ReferencedValue", "dataPointer", "value", "aBuffer", "bBuffer", "a", "b", "len", "idx", "compareReferencedValues", "valueComparison", "values", "target", "n", "i", "j", "h", "N", "PAGE_SIZE_BYTES", "maxUint64", "LinkedMetaPage", "resolver", "offset", "data", "view", "pointerOffset", "lengthOffset", "pageData", "metadataLength", "start", "res", "offsets", "idx", "nextOffset", "ReadMultiBPTree", "QueryBuilder", "_QueryBuilder", "database", "key", "operation", "value", "newQuery", "direction", "keys", "limit", "processWhere", "value", "valueBuf", "handleSelect", "data", "select", "jData", "acc", "field", "checkType", "headerType", "queryType", "validateWhere", "where", "headers", "whereNode", "header", "h", "validateOrderBy", "orderBy", "whereKey", "orderByObj", "validateSelect", "select", "hset", "s", "validateQuery", "query", "FieldType", "fieldTypeToString", "f", "str", "Database", "_Database", "dataFile", "indexFile", "query", "where", "format", "dfResolver", "headers", "validateQuery", "key", "value", "operation", "header", "res", "processWhere", "fieldType", "valueBuf", "mp", "mpFieldType", "readIndexMeta", "ord", "bptree", "BPTree", "valueRef", "ReferencedValue", "iter", "currentKey", "data", "handleSelect", "lastKey", "maxUint64", "firstKey", "QueryBuilder", "IndexFile", "_IndexFile", "url", "config", "ranges", "requestRanges", "resolver", "IndexFileV1", "tree", "ReadMultiBPTree", "buffer", "dataView", "version", "formatByte", "FileFormat", "readOffset", "header", "fieldType", "headerMps", "idx", "mp", "indexMeta", "readIndexMeta", "currMp", "offsets", "o", "PAGE_SIZE_BYTES", "res", "data", "LinkedMetaPage", "indexMetas", "im", "collectIndexMetas", "init", "dataUrl", "indexUrl", "config", "Database", "DataFile", "IndexFile", "FieldType", "fieldTypeToString"]
}
