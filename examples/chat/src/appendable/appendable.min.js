function Z(n) {
  let e = null,
    t = !1,
    r = n.getReader();
  return async (a) => {
    if (r instanceof ReadableStreamBYOBReader) return await r.read(a);
    for (;;) {
      if (e) {
        let l = Math.min(e.length, a.length);
        return (
          a.set(e.subarray(0, l)),
          (e = e.subarray(l)),
          e.length === 0 && (e = null),
          { done: t && e === null, value: a.subarray(0, l) }
        );
      }
      let o = await r.read();
      o.value && (e = o.value), (t ||= o.done);
    }
  };
}
function X(n) {
  let e = n.split(" ");
  if (e.length !== 2) throw new Error("Invalid Content-Range header");
  let [t, r] = e[1].split("/"),
    [a, o] = t.split("-");
  return [e[0], Number(a), Number(o), Number(r)];
}
async function* $(n, e) {
  let t = Z(e),
    r = n.split(";");
  if (r[0] !== "multipart/byteranges")
    throw new Error("Not a multipart/byteranges body");
  let a = r
    .map((c) => c.trim())
    .find((c) => c.startsWith("boundary="))
    ?.split("=", 2)?.[1];
  if (!a) throw new Error("No boundary found");
  let o = `--${a}`,
    l = {},
    d = new Uint8Array(4096),
    i = 0,
    u = 0,
    b = async () => {
      if (u === d.byteLength) throw new Error("no buffer space left");
      let { done: c, value: p } = await t(
        i + u >= d.length
          ? d.subarray((i + u) % d.length, i)
          : d.subarray(i + u, d.length),
      );
      return c || ((u += p.length), !1);
    };
  for (;;) {
    for (let s = 0; s < o.length; s++) {
      for (; u === 0; ) if (await b()) return;
      if (d[i] !== o.charCodeAt(s))
        throw (
          (console.log("boundary.charCode", d[i], o.charCodeAt(s), s),
          new Error("Invalid boundary"))
        );
      (i = (i + 1) % d.length), u--;
    }
    for (let s of [
      "\r",
      `
`,
    ]) {
      for (; u === 0; ) if (await b()) return;
      if (d[i] === s.charCodeAt(0)) (i = (i + 1) % d.length), u--;
      else {
        if (d[i] === 45) return;
        throw new Error("Invalid boundary");
      }
    }
    let c = 0,
      p = [];
    for (;;) {
      for (; u === 0; ) if (await b()) return;
      let s = d[i];
      if (((i = (i + 1) % d.length), u--, c === 13 && s === 10)) {
        if (p.length === 1) break;
        {
          let m = new TextDecoder().decode(new Uint8Array(p)),
            f = m.split(":", 2);
          if (f.length !== 2) throw new Error(`Invalid header: ${m}`);
          let [g, Y] = f;
          (l[g.trim()] = Y.trim()), (p.length = 0);
        }
      } else p.push(s);
      c = s;
    }
    if (!l["Content-Range"]) throw new Error("Missing Content-Range header");
    let [x, L, P] = X(l["Content-Range"]);
    if (x !== "bytes") throw new Error("Invalid Content-Range header");
    let w = P - L + 1,
      h = new Uint8Array(w);
    for (let s = 0; s < w; s++) {
      for (; u === 0; ) if (await b()) return;
      (h[s] = d[i]), (i = (i + 1) % d.length), u--;
    }
    yield { data: h.buffer, headers: l }, (l = {});
    for (let s of [
      "\r",
      `
`,
    ]) {
      for (; u === 0; ) if (await b()) return;
      if (d[i] === s.charCodeAt(0)) (i = (i + 1) % d.length), u--;
      else throw new Error("Invalid boundary");
    }
  }
}
var M = class extends Error {
  constructor() {
    super("length integrity error");
  }
};
async function H(n, e) {
  let t = e.map(async ({ start: r, end: a, expectedLength: o }) => {
    let l = `${r}-${a}`,
      d = await fetch(n, { headers: { Range: `bytes=${l}` } }),
      i = Number(d.headers.get("Content-Range").split("/")[1]);
    if (o && i !== o) throw new M();
    return { data: await d.arrayBuffer(), totalLength: i };
  });
  return await Promise.all(t);
}
async function A(n, e, t) {
  let { useMultipartByteRanges: r } = t;
  if (r === !1) return await H(n, e);
  let a = e.map(({ start: l, end: d }) => `${l}-${d}`).join(","),
    o = await fetch(n, {
      headers: { Range: `bytes=${a}`, Accept: "multipart/bytesranges" },
    });
  switch (o.status) {
    case 200:
      return (
        console.warn(
          "useMultipartByteRanges is enabled but the server indicated did not respond with a subset of bytes. Set useMultipartByteRanges: false in your Appendable config object.",
        ),
        await H(n, e)
      );
    case 206:
      let l = o.headers.get("Content-Type");
      if (!l) throw new Error("Missing Content-Type in response");
      if (l.includes("multipart/byteranges")) {
        let i = [];
        if (!o.body) throw new Error(`response body is null: ${o.body}`);
        for await (let u of $(l, o.body)) i.push(u);
        return (
          i[i.length - 1].data === void 0 && i.pop(),
          i.map(({ data: u, headers: b }) => {
            let c = b["content-range"]?.split("/")[1],
              p = c ? parseInt(c, 10) : 0;
            return { data: u, totalLength: p };
          })
        );
      } else if (o.headers.has("Content-Range")) {
        let i = await o.arrayBuffer(),
          u = Number(o.headers.get("Content-Range").split("/")[1]);
        return [{ data: i, totalLength: u }];
      } else throw new Error(`Unexpected response format: ${l}`);
    case 416:
      let d = o.headers.get("Range") || a;
      throw new Error(`Resolver cannot serve the requested ranges: ${d}`);
    default:
      throw new Error(`Expected 206 or 200 response, got ${o.status}`);
  }
}
var B = class n {
  constructor(e) {
    this.resolver = e;
  }
  static forUrl(e, t) {
    return n.forResolver(async (r) => await A(e, r, t));
  }
  static forResolver(e) {
    let t = new n(async (r) => await e(r));
    return (t.originalResolver = e), t;
  }
  getResolver() {
    return this.originalResolver;
  }
  async get(e, t) {
    let r = await this.resolver([{ start: e, end: t }]);
    return new TextDecoder().decode(r[0].data);
  }
};
var E = ((t) => ((t[(t.JSONL = 0)] = "JSONL"), (t[(t.CSV = 1)] = "CSV"), t))(
  E || {},
);
async function k(n) {
  if (n.byteLength < 4)
    throw new Error(`invalid metadata size ${n.byteLength}`);
  let e = new DataView(n),
    t = e.getUint16(0, !0),
    r = e.getUint16(2, !0);
  if (n.byteLength < 4 + r)
    throw new Error(`invalid metadata size ${n.byteLength}`);
  let a = n.slice(4, 4 + r);
  return { fieldName: new TextDecoder("utf-8").decode(a), fieldType: t };
}
function Q(n) {
  let e = new Map();
  for (let r of n)
    if (!e.has(r.fieldName)) e.set(r.fieldName, [r.fieldType]);
    else {
      let a = e.get(r.fieldName);
      a?.push(r.fieldType), e.set(r.fieldName, a);
    }
  let t = [];
  return (
    e.forEach((r, a) => {
      t.push({ fieldName: a, fieldTypes: r });
    }),
    t
  );
}
var _ = 4096,
  S = class n {
    constructor(e, t, r, a, o, l) {
      (this.keys = e),
        (this.leafPointers = t),
        (this.internalPointers = r),
        (this.dataFileResolver = a),
        (this.fileFormat = o),
        (this.pageFieldType = l);
    }
    leaf() {
      return this.leafPointers.length > 0;
    }
    pointer(e) {
      return this.leaf()
        ? this.leafPointers[e]
        : { offset: this.internalPointers[e], length: 0 };
    }
    numPointers() {
      return this.internalPointers.length + this.leafPointers.length;
    }
    size() {
      let e = 4;
      for (let t = 0; t <= this.keys.length - 1; t++) {
        let r = this.keys[t];
        r.dataPointer.length > 0 ? (e += 16) : (e += 4 * r.value.byteLength);
      }
      for (let t = 0; t <= this.leafPointers.length - 1; t++) e += 12;
      for (let t = 0; t <= this.internalPointers.length - 1; t++) e += 8;
      return BigInt(e);
    }
    async unmarshalBinary(e) {
      let t = new DataView(e),
        r = t.getUint32(0, !0);
      if (
        (r > 2147483647 && (r = r - 4294967296),
        r < 0
          ? ((this.leafPointers = new Array(-r)
              .fill({ offset: 0n, length: 0 })
              .map(() => ({ offset: 0n, length: 0 }))),
            (this.keys = new Array(-r)
              .fill(null)
              .map(() => new y({ offset: 0n, length: 0 }, new ArrayBuffer(0)))))
          : ((this.internalPointers = Array(r + 1)
              .fill(0n)
              .map(() => 0n)),
            (this.keys = new Array(r)
              .fill(null)
              .map(
                () => new y({ offset: 0n, length: 0 }, new ArrayBuffer(0)),
              ))),
        r === 0)
      )
        throw new Error("empty node");
      let o = [],
        l = [],
        d = 4;
      for (let i = 0; i <= this.keys.length - 1; i++) {
        t = new DataView(e, d);
        let u = t.getBigUint64(0, !0),
          b = t.getUint32(8, !0);
        d += 12;
        let c = t.getUint32(12, !0);
        if (
          ((d += 4),
          this.keys[i].setDataPointer({ offset: u, length: b }),
          c === -1 >>> 0)
        ) {
          let p = this.keys[i].dataPointer;
          o.push({
            start: Number(p.offset),
            end: Number(p.offset) + p.length - 1,
          }),
            l.push(i);
        } else {
          let p = e.slice(d, d + c);
          this.keys[i].setValue(p), (d += p.byteLength);
        }
      }
      o.length > 0 &&
        (await this.dataFileResolver(o)).forEach((u, b) => {
          let c = l[b],
            { data: p } = u,
            x = this.parseValue(p);
          this.keys[c].setValue(x);
        });
      for (let i = 0; i <= this.leafPointers.length - 1; i++)
        (t = new DataView(e, d)),
          (this.leafPointers[i].offset = t.getBigUint64(0, !0)),
          (this.leafPointers[i].length = t.getUint32(8, !0)),
          (d += 12);
      for (let i = 0; i <= this.internalPointers.length - 1; i++)
        (t = new DataView(e, d)),
          (this.internalPointers[i] = t.getBigUint64(0, !0)),
          (d += 8);
    }
    parseValue(e) {
      let t = new TextDecoder().decode(e);
      switch (this.fileFormat) {
        case 0:
          let r = JSON.parse(t);
          switch (this.pageFieldType) {
            case 7:
              if (r !== null)
                throw new Error(`unrecognized value for null type: ${r}`);
              return new ArrayBuffer(0);
            case 6:
              return new Uint8Array([r ? 1 : 0]).buffer;
            case 3:
            case 1:
            case 2:
              let a = new ArrayBuffer(8);
              return new DataView(a).setFloat64(0, r), a;
            case 0:
              return new TextEncoder().encode(r).buffer;
            default:
              throw new Error(
                `Unexpected Field Type. Got: ${this.pageFieldType}`,
              );
          }
        case 1:
          return e;
      }
    }
    static async fromMemoryPointer(e, t, r, a, o) {
      let l = await t([
          { start: Number(e.offset), end: Number(e.offset) + 4096 - 1 },
        ]),
        { data: d } = l[0],
        i = new n([], [], [], r, a, o);
      return await i.unmarshalBinary(d), { node: i, bytesRead: _ };
    }
  };
var I = class {
  constructor(e, t) {
    (this.tree = e), (this.key = t), (this.records = []);
  }
  async init() {
    let e = await this.tree.root();
    if (e.rootNode === null) return !1;
    let t = e.rootNode,
      r = e.pointer,
      a = await this.tree.traverse(this.key, t, r);
    return (this.records = a), !0;
  }
  getKey() {
    return this.records[0].node.keys[this.records[0].index];
  }
  getPointer() {
    return this.records[0].node.pointer(this.records[0].index);
  }
  async increment(e, t) {
    if (e === this.records.length) return !1;
    this.records[e].index += t;
    let r = this.records[e].index < 0,
      a = this.records[e].index >= this.records[e].node.numPointers();
    if (r || a) {
      if (!this.increment(e + 1, t) || !this.records[e + 1]) return !1;
      let o = await this.tree.readNode(
        this.records[e + 1].node.pointer(this.records[e + 1].index),
      );
      (this.records[e].node = o),
        r
          ? (this.records[e].index = this.records[e].node.numPointers() - 1)
          : (this.records[e].index = 0);
    }
    return !0;
  }
  async next() {
    return this.records.length === 0 ? await this.init() : this.increment(0, 1);
  }
  async prev() {
    return this.records.length === 0 && !(await this.init())
      ? !1
      : this.increment(0, -1);
  }
};
var O = class {
    constructor(e, t, r, a, o) {
      (this.tree = e),
        (this.meta = t),
        (this.dataFileResolver = r),
        (this.fileFormat = a),
        (this.pageFieldType = o);
    }
    async root() {
      let e = await this.meta.root();
      if (!e || e.length === 0) return { rootNode: null, pointer: e };
      let t = await this.readNode(e);
      return t ? { rootNode: t, pointer: e } : { rootNode: null, pointer: e };
    }
    async readNode(e) {
      try {
        let { node: t, bytesRead: r } = await S.fromMemoryPointer(
          e,
          this.tree,
          this.dataFileResolver,
          this.fileFormat,
          this.pageFieldType,
        );
        if (!r) throw new Error("bytes read do not line up");
        return t;
      } catch (t) {
        throw new Error(`${t}`);
      }
    }
    iter(e) {
      return new I(this, e);
    }
    async first() {
      let { rootNode: e } = await this.root();
      if (!e) throw new Error("unable to get root node");
      let t = await this.readNode(e.pointer(0));
      for (; !t.leaf(); ) {
        let r = t.pointer(0);
        t = await this.readNode(r);
      }
      return t.keys[0];
    }
    async last() {
      let { rootNode: e } = await this.root();
      if (!e) throw new Error("unable to get root node");
      let t = await this.readNode(e.pointer(e.numPointers() - 1));
      for (; !t.leaf(); ) {
        let r = t.pointer(t.numPointers() - 1);
        t = await this.readNode(r);
      }
      return t.keys[t.keys.length - 1];
    }
    async traverse(e, t, r) {
      let [a, o] = ee(t.keys, e);
      if (t.leaf()) return [{ node: t, index: a, pointer: r }];
      o && (a += 1);
      let l = t.pointer(a),
        d = await this.readNode(l);
      return [
        ...(await this.traverse(e, d, l)),
        { node: t, index: a, pointer: r },
      ];
    }
    async find(e) {
      let t = this.iter(e);
      return (await t.next())
        ? [t.getKey(), t.getPointer()]
        : [
            new y({ offset: 0n, length: 0 }, new Uint8Array(0).buffer),
            { offset: 0n, length: 0 },
          ];
    }
  },
  y = class {
    constructor(e, t) {
      (this.dataPointer = e), (this.value = t);
    }
    setDataPointer(e) {
      this.dataPointer = e;
    }
    setValue(e) {
      this.value = e;
    }
    static compareBytes(e, t) {
      let r = new Uint8Array(e),
        a = new Uint8Array(t),
        o = Math.min(r.length, a.length);
      for (let l = 0; l < o; l++)
        if (r[l] !== a[l]) return r[l] < a[l] ? -1 : 1;
      return r.length < a.length ? -1 : r.length > a.length ? 1 : 0;
    }
  };
function W(n, e) {
  let t = y.compareBytes(n.value, e.value);
  return t !== 0
    ? t
    : n.dataPointer.offset > e.dataPointer.offset
      ? 1
      : n.dataPointer.offset < e.dataPointer.offset
        ? -1
        : n.dataPointer.length > e.dataPointer.length
          ? 1
          : n.dataPointer.length < e.dataPointer.length
            ? -1
            : 0;
}
function ee(n, e) {
  let t = n.length,
    r = 0,
    a = t;
  for (; r < a; ) {
    let o = Math.floor((r + a) / 2);
    W(n[o], e) < 0 ? (r = o + 1) : (a = o);
  }
  return [r, r < t && W(n[r], e) === 0];
}
var j = 16,
  V = 4096,
  D = 2n ** 64n - 1n,
  N = class {
    constructor(e, t, r) {
      (this.resolver = e), (this.offset = t), (this.metaPageData = r);
    }
    async root() {
      let t = (await this.getMetaPage()).slice(0, 12),
        r = new DataView(t),
        a = r.getBigUint64(0, !0),
        o = r.getUint32(8, !0);
      return { offset: a, length: o };
    }
    async metadata() {
      let e = await this.getMetaPage(),
        r = new DataView(e, 8 * j + 16).getUint32(0, !0),
        a = 8 * j + 20;
      return e.slice(a, a + r);
    }
    setMetaPage(e) {
      this.metaPageData = e;
    }
    async getMetaPage() {
      if (this.metaPageData) return this.metaPageData;
      this.metaPageDataPromise ||
        (this.metaPageDataPromise = this.resolver([
          { start: Number(this.offset), end: Number(this.offset) + V - 1 },
        ]));
      let e = await this.metaPageDataPromise,
        { data: t } = e[0];
      return t;
    }
    async nextNOffsets() {
      let e = await this.getMetaPage(),
        t = new DataView(e, 12),
        r = [];
      for (let a = 0; a <= j - 1; a++) {
        let o = t.getBigUint64(a * 8, !0);
        if (o === D) return r;
        r.push(o);
      }
      return r;
    }
    getOffset() {
      return this.offset;
    }
  };
function q(n, e) {
  let t = e < 0 ? BigInt(0) : BigInt(e + 1) * BigInt(V);
  return new N(n, t);
}
var C = class n {
  constructor(e) {
    this.database = e;
    this.queryObject = {
      where: [],
      orderBy: void 0,
      select: void 0,
      limit: void 0,
    };
  }
  toQuery() {
    return {
      where: this.queryObject.where ? [...this.queryObject.where] : [],
      orderBy: this.queryObject.orderBy
        ? [...this.queryObject.orderBy]
        : void 0,
      select: this.queryObject.select ? [...this.queryObject.select] : void 0,
      limit: this.queryObject.limit,
    };
  }
  get() {
    return this.database.query(this.queryObject);
  }
  where(e, t, r) {
    let a = new n(this.database);
    return (
      (a.queryObject = {
        ...this.queryObject,
        where: [
          ...(this.queryObject.where || []),
          { key: e, operation: t, value: r },
        ],
      }),
      a
    );
  }
  orderBy(e, t) {
    let r = new n(this.database);
    return (
      (r.queryObject = {
        ...this.queryObject,
        orderBy: [
          ...(this.queryObject.orderBy || []),
          { key: e, direction: t },
        ],
      }),
      r
    );
  }
  select(e) {
    let t = new n(this.database);
    return (t.queryObject = { ...this.queryObject, select: e }), t;
  }
  limit(e) {
    let t = new n(this.database);
    return (t.queryObject = { ...this.queryObject, limit: e }), t;
  }
};
function z(n) {
  let e;
  if (n === null) return { fieldType: 7, valueBuf: new ArrayBuffer(0) };
  switch (typeof n) {
    case "bigint":
    case "number":
      return (
        (e = new ArrayBuffer(8)),
        new DataView(e).setFloat64(0, Number(n)),
        { fieldType: 3, valueBuf: e }
      );
    case "boolean":
      return { fieldType: 6, valueBuf: new Uint8Array([n ? 1 : 0]).buffer };
    case "string":
      return { fieldType: 0, valueBuf: new TextEncoder().encode(n).buffer };
  }
  return null;
}
function v(n, e) {
  let t = JSON.parse(n);
  return e && e.length > 0
    ? e.reduce((r, a) => (a in t && (r[a] = t[a]), r), {})
    : t;
}
function T(n, e) {
  return n.includes(e);
}
function te(n, e) {
  if (!n || !Array.isArray(n) || n.length === 0)
    throw new Error("Missing 'where' clause.");
  for (let t of n) {
    if (!["<", "<=", "==", ">=", ">"].includes(t.operation))
      throw new Error("Invalid operation in 'where' clause.");
    if (typeof t.key != "string")
      throw new Error("'key' in 'where' clause must be a string.");
    let r = e.find((o) => o.fieldName === t.key);
    if (!r)
      throw new Error(
        `key: ${t.key} in 'where' clause does not exist in dataset.`,
      );
    if (typeof t.value > "u")
      throw new Error("'value' in 'where' clause is missing.");
    let a = r.fieldTypes;
    if (t.value === null) {
      if (!T(a, 7))
        throw new Error(`null type not included in ${t.key}'s header types.`);
    } else
      switch (typeof t.value) {
        case "bigint":
        case "number":
          if (!T(a, 3) && !T(a, 2) && !T(a, 1))
            throw new Error(
              `number type not included in ${t.key}'s header types.`,
            );
          break;
        case "string":
          if (!T(a, 0))
            throw new Error(
              `string type not included in ${t.key}'s header types`,
            );
          break;
        case "boolean":
          if (!T(a, 6))
            throw new Error(
              `boolean type not included in ${t.key}'s header types`,
            );
          break;
        default:
          throw new Error(
            `unrecognized type: ${typeof t.value} not included in ${t.key}'s header types`,
          );
      }
  }
}
function re(n, e) {
  if (n) {
    if (!Array.isArray(n) || n.length === 0)
      throw new Error("Invalid 'orderBy' clause.");
    let t = n[0];
    if (!["ASC", "DESC"].includes(t.direction))
      throw new Error("Invalid direction in `orderBy`.");
    if (t.key !== e)
      throw new Error("'key' in `orderBy` must match `key` in `where` clause");
  }
}
function ne(n, e) {
  if (n) {
    if (!Array.isArray(n)) throw new Error(`select is not an array: ${n}`);
    if (n.length <= 0) throw new Error(`select clause is empty: ${n}`);
    let t = new Set();
    e.map((r) => t.add(r.fieldName)),
      n.map((r) => {
        if (!t.has(r))
          throw new Error(`${r} is not included in the field name headers`);
      });
  }
}
function G(n, e) {
  te(n.where, e), re(n.orderBy, n.where[0].key), ne(n.select, e);
}
var R = ((i) => (
  (i[(i.String = 0)] = "String"),
  (i[(i.Int64 = 1)] = "Int64"),
  (i[(i.Uint64 = 2)] = "Uint64"),
  (i[(i.Float64 = 3)] = "Float64"),
  (i[(i.Object = 4)] = "Object"),
  (i[(i.Array = 5)] = "Array"),
  (i[(i.Boolean = 6)] = "Boolean"),
  (i[(i.Null = 7)] = "Null"),
  i
))(R || {});
function J(n) {
  let e;
  switch (n) {
    case 0:
      e = "String";
      break;
    case 1:
      e = "Int64";
      break;
    case 2:
      e = "Uint64";
      break;
    case 3:
      e = "Float64";
      break;
    case 4:
      e = "Object";
      break;
    case 5:
      e = "Array";
      break;
    case 6:
      e = "Boolean";
      break;
    case 7:
      e = "Null";
      break;
  }
  return e;
}
var U = class n {
  constructor(e, t) {
    this.dataFile = e;
    this.indexFile = t;
  }
  static forDataFileAndIndexFile(e, t) {
    return new n(e, t);
  }
  async fields() {
    return (
      this.indexHeadersPromise ||
        (this.indexHeadersPromise = this.indexFile.indexHeaders()),
      this.indexHeadersPromise
    );
  }
  async *query(e) {
    if (new Set((e.where ?? []).map((o) => o.key)).size > 1)
      throw new Error("composite indexes not supported... yet");
    let { format: t } = await this.indexFile.metadata(),
      r = this.dataFile.getResolver();
    if (!r) throw new Error("data file is undefined");
    let a = await this.fields();
    G(e, a);
    for (let { key: o, value: l, operation: d } of e.where ?? []) {
      if (!a.find((h) => h.fieldName === o)) throw new Error("field not found");
      let u = z(l);
      if (u === null)
        throw new Error(`unable to process key with a type ${typeof l}`);
      let { fieldType: b, valueBuf: c } = u,
        x = (await this.indexFile.seek(o, b))[0],
        { fieldType: L } = await k(await x.metadata()),
        P = "ASC";
      e.orderBy && e.orderBy[0] && (P = e.orderBy[0].direction);
      let w = new O(this.indexFile.getResolver(), x, r, t, L);
      if (d === ">")
        if (P === "ASC") {
          let h = new y({ offset: 0n, length: 0 }, c),
            s = w.iter(h);
          for (; await s.next(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) < 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        } else {
          let h = await w.last(),
            s = w.iter(h);
          for (; await s.prev(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) < 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        }
      else if (d === ">=")
        if (P === "ASC") {
          let h = new y({ offset: 0n, length: 0 }, c),
            s = w.iter(h);
          for (; await s.next(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) <= 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        } else {
          let h = await w.last(),
            s = w.iter(h);
          for (; await s.prev(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) <= 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        }
      else if (d === "==") {
        let h = new y({ offset: 0n, length: 0 }, c),
          s = w.iter(h);
        for (; await s.next(); ) {
          let m = s.getKey();
          if (y.compareBytes(c, m.value) === 0) {
            let f = s.getPointer(),
              g = await this.dataFile.get(
                Number(f.offset),
                Number(f.offset) + f.length - 1,
              );
            yield v(g, e.select);
          }
        }
      } else if (d === "<=")
        if (P === "DESC") {
          let h = new y({ offset: D, length: 0 }, c),
            s = w.iter(h);
          for (; await s.prev(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) >= 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        } else {
          let h = await w.first(),
            s = w.iter(h);
          for (; await s.next(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) >= 0) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        }
      else if (d === "<")
        if (P === "DESC") {
          let h = new y({ offset: D, length: 0 }, c),
            s = w.iter(h);
          for (; await s.prev(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) === 1) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        } else {
          let h = await w.first(),
            s = w.iter(h);
          for (; await s.next(); ) {
            let m = s.getKey();
            if (y.compareBytes(c, m.value) === 1) {
              let f = s.getPointer(),
                g = await this.dataFile.get(
                  Number(f.offset),
                  Number(f.offset) + f.length - 1,
                );
              yield v(g, e.select);
            }
          }
        }
    }
  }
  where(e, t, r) {
    return new C(this).where(e, t, r);
  }
};
var F = class n {
    static async forUrl(e, t) {
      return await n.forResolver(async (r) => await A(e, r, t));
    }
    static async forResolver(e) {
      return new K(e);
    }
  },
  K = class {
    constructor(e) {
      this.resolver = e;
      this.linkedMetaPages = [];
    }
    getResolver() {
      return this.resolver;
    }
    async tree() {
      if (this._tree) return this._tree;
      let e = q(this.resolver, 0);
      return (this._tree = e), e;
    }
    async metadata() {
      let t = await (await this.tree()).metadata();
      if (t.byteLength < 10)
        throw new Error(`incorrect byte length! Want: 10, got ${t.byteLength}`);
      let r = new DataView(t),
        a = r.getUint8(0),
        o = r.getUint8(1);
      if (Object.values(E).indexOf(o) === -1)
        throw new Error(`unexpected file format. Got: ${o}`);
      let l = r.getBigUint64(2, !0);
      return { version: a, format: o, readOffset: l };
    }
    async seek(e, t) {
      this.linkedMetaPages.length === 0 && (await this.fetchMetaPages());
      let r = [];
      for (let a = 0; a <= this.linkedMetaPages.length - 1; a++) {
        let o = this.linkedMetaPages[a],
          l = await k(await o.metadata());
        l.fieldName === e &&
          (t === 3
            ? (l.fieldType === 3 || l.fieldType === 1 || l.fieldType === 2) &&
              r.push(o)
            : l.fieldType === t && r.push(o));
      }
      return r;
    }
    async fetchMetaPages() {
      let e = await this.tree(),
        t = await e.nextNOffsets();
      for (; t.length > 0; ) {
        let r = t.map((l) => ({ start: Number(l), end: Number(l) + V - 1 })),
          a = await this.resolver(r),
          o = 0;
        for (let { data: l } of a)
          this.linkedMetaPages.push(new N(this.resolver, t[o], l)), o++;
        (e = this.linkedMetaPages[this.linkedMetaPages.length - 1]),
          (t = await e.nextNOffsets());
      }
    }
    async indexHeaders() {
      this.linkedMetaPages.length === 0 && (await this.fetchMetaPages());
      let e = [];
      for (let t of this.linkedMetaPages) {
        let r = await k(await t.metadata());
        e.push(r);
      }
      return Q(e);
    }
  };
async function ae(n, e, t) {
  return (
    t || (t = { useMultipartByteRanges: !0 }),
    U.forDataFileAndIndexFile(
      typeof n == "string" ? B.forUrl(n, t) : B.forResolver(n),
      typeof e == "string" ? await F.forUrl(e, t) : await F.forResolver(e),
    )
  );
}
globalThis.Appendable = { init: ae, FieldType: R, fieldTypeToString: J };
export { ae as init };
//# sourceMappingURL=appendable.min.js.map
